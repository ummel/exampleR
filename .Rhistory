# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#for (x in ls(pattern = "fitted_model")[-1]) {
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
head(nd)
v <- c("elec", "gas")
m <- fitted_model0
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
x <- cbind(nd, expand.grid(g))
dim(x)
head(x)
View(x)
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
v <- c("elec", "gas")
m <- fitted_model0
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
x <- cbind(nd, expand.grid(g))
x$y <- predict.gbm(m, newdata = x, n.trees = m$n.trees)
head(x)
summary(x)
f <- paste0("y ~ ", paste(v, collapse = " + "))
f
f <- paste0("y ~ ", paste(v, collapse = " + "))
fit <- lm(formula = formula(f), data = x)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
n <- prettyNum(signif(coef(fit), 4))
names(n)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", n, names(n)), collapse = " + ")), fixed = TRUE)
fit
summary(fit)
eq
#for (x in ls(pattern = "fitted_model")[-1]) {  # Not sure if ls() works within package environment
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
nd
out <- subset(nd, select = c(mrate, div_pre, div_post, elec, gas))
out$cost <- eq
out
predictModel <- function(input) {
#input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input)
} else {
as.data.frame(input)
}
stopifnot("zip" %in% names(nd))
stopifnot("hhsize" %in% names(nd))
stopifnot("minors" %in% names(nd))
stopifnot("age" %in% names(nd))
#-----
# INPUT FOR TESTING:
#nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 50e3, elec = 100)
#nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#------
# How does variation in income affect the result
# TO DO: THIS NEEDS TO REFLECT SPECIFIC INPUTS NOT INTEGRAL OVER ALL VALUES!!!
v <- c("elec", "gas")
m <- fitted_model0
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
x <- cbind(nd, expand.grid(g))
x$y <- predict.gbm(m, newdata = x, n.trees = m$n.trees)
f <- paste0("y ~ ", paste(v, collapse = " + "))
fit <- lm(formula = formula(f), data = x)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
n <- prettyNum(signif(coef(fit), 4))
names(n)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", n, names(n)), collapse = " + ")), fixed = TRUE)
#------
# Predict the slider preset values
#for (x in ls(pattern = "fitted_model")[-1]) {  # Not sure if ls() works within package environment
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
#------
# DEPRECATED
# pred <- setdiff(names(test), "y")
# fit0 <- lm(y ~ ., data = test)
# fit0 <- lm(y ~ poly(income, 1, raw = T) * poly(elec, 1, raw = T), data = test)
#fit <- lm(formula = formula(paste0("y ~ ", paste0("poly(", pred, ", degree = 3, raw = TRUE)"))), data = test)
#fit2 <- as.stepfun(isoreg(x = test$income, y = test$y))
#library(MonoPoly)
#fit3 <- monpol(y ~income, data = test, degree = 5, monotone = "increasing")
# Check fit
# plot(test)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 2)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 3)
#-----
# Return results data frame
out <- subset(nd, select = c(div_pre, mrate, elec, gas))
out$cost <- eq
return(out)
}
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 3, age = 50, income = 50e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 30e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 7, minors = 2, age = 50, income = 30e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 2, minors = 0, age = 50, income = 30e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 2, minors = 0, age = 30, income = 30e3))
summary(fitted_model0)
predictModel(nd <- data.frame(zip = "80524", hhsize = 2, minors = 0, age = 30, income = 70e3))
library(exampleR)
round(1131 * (1 - 0.15))
449.6 + 0.4673 * 101 + 2.051 * 73
961-647
?roxygenize
library(roxygen2)
roxygenise()
library(devtools)
build()
library(exampleR)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7")
predictModel(nd)
library(quantreg)
library(tidyverse)
#----------------------
shrinkModel <- function(b, data) {
orig <- predict(b, data)
tryFun <- function(i, x) {
tryCatch(
{
x[[i]] <- NULL
y = predict(x, data)
identical(y, orig)
},
error = function(cond) {
return(FALSE)
},
warning = function(cond) {
message(cond)
return(FALSE)
},
finally = {}
)
}
cand <- sort(sapply(b, object.size), decreasing = TRUE)
for (j in names(cand)) {
if (tryFun(j, b)) {
b[[j]] <- NULL
}
}
return(b)
}
#----------------------------------
dset <- read_rds("Data/Model fitting dataset.rds") %>%
filter(hinc_fpl >= 0.25, age >= 18, na >= 1, Electricity > 0, !(!hfuel %in% c("Electricity", "Other or none") & Heating == 0), !(veh > 0 & Gasoline == 0)) %>%
mutate(veh = as.character(veh),
veh = as.ordered(ifelse(veh %in% c(5, "6+"), "5+", veh)),
rms = ordered(ifelse(rms >= 12, "12+", rms), levels = c(1:11,"12+")),
hfuel = ifelse(hfuel == "LPG", "LPG/Propane", hfuel),
hfuel = factor(hfuel, levels = names(sort(table(hfuel), decreasing = TRUE))),
Gasoline = Gasoline / gasprice,
Electricity = Electricity / elecprice,
Heating = Heating / heatprice)
# Predictor variables that are "fixed"
# These include number of adults and children and household income (necessary for post-tax dividend calculation)
#  as well as heating fuel and any predictors based on household location (assigned via user zip code)
#fixed <- c("np", "na", "nc", "hinc", "hfuel", "state", "loc", "popd", "cdd", "hdd", grep("ratio", names(dset), value = TRUE), grep("_pindex", names(dset), value = TRUE))
#fixed <- c("np", "na", "nc", "hinc", "hinc_fpl", "hfuel", "state", "loc", "popd", "cdd", "hdd", grep("_ratio", names(dset), value = TRUE), grep("_index", names(dset), value = TRUE))
fixed <- c("np", "nc", "hinc", "hfuel", "state", "loc", "popd", "cdd", "hdd", grep("ratio", names(dset), value = TRUE))
# Selected additional predictor variables
pred <- c("veh", "rms")
# Full set of predictor variables
vars <- c(fixed, pred)
#----------------------------------
# Convert character variables to factors to avoid error generated by gbm()
i <- which(sapply(dset, class) == "character")
dset[i] <- lapply(dset[i], as.factor)
# Drop observations where numeric variables have extreme values
n <- which(sapply(dset, class) == "numeric")
n <- n[names(n) %in% vars]
rng <- lapply(n, function(i) {quantile(dset[[i]], probs = c(0.01, 0.99))})
for (i in 1:length(n)) {
vrng <- rng[[i]]
dset <- filter(dset, dset[[n[i]]] > vrng[1], dset[[n[i]]] < vrng[2])
}
library(exampleR)
inputSummary()
roxygen2::roxygenise()
library(exampleR)
inputSummary()
ls()
.onLoad()
.onLoad(exampleR)
library(exampleR)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7")
predictModel(nd)
ls()
roxygen2::roxygenize()
library(exampleR)
nd
prettyNum()
?orettyNum
prettyNum
?prettyNum
prettyNum(96)
?round
round(96, 2)
round(96, -1)
round(96, -2)
round(196, -1)
round(196, -2)
round(76, -2)
round(76, -1)
round(74, -1)
ceiling(76, -1)
library(exampleR)
inputSummary
inputSummary()
inputSummary(x="")
data("input_summary")
ls()
roxygen2::roxygenise()
library(exampleR)
inputSummary()
library(exampleR)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Other or none", veh = "2", rms = "7")
predictModel <- function(input) {
#input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input)
} else {
as.data.frame(input)
}
# Check that all necessary input variables are present
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("rms" %in% nms)
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup, sort = FALSE)
nd <- nd[order(nd$id),]
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
div.adult <- 377
# #TO DO: Estimate household marginal tax rate
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
#nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd$np <- nd$na + nd$na
nd$elec_ratio <- nd$cents_kwh / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice / (nd$hinc / 1e3)
#----------------------
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
q <- predict(core_model, newdata = nd)
core <- q[,2]
stdev <- apply(q, 1, function(x) diff(x[c(1,3)])) / 1.35
#----------------------
# Gasoline weekly expenditure (median and 95th percentile)
gas <- signif(predict(gas_model, newdata = nd) * nd$gasprice / 52, digits = 2)
colnames(gas) <- c("gas", "gas_upr")
# Electricity monthly expenditure (median and 95th percentile)
elec <- signif(predict(elec_model, newdata = nd) * nd$cents_kwh / 12, digits = 2)
colnames(elec) <- c("elec", "elec_upr")
# Primary heating fuel monthly expenditure (median and 95th percentile)
predHeatModels <- function(d) {
if (d$hfuel[1] == "Natural gas") {
d$heat_ratio <- d$ngasprice / (d$hinc / 1e3)
out <- predict(ngas_model, newdata = d) * d$ngasprice
out <- cbind(out, d$Natural_gas_cie)
}
if (d$hfuel[1] == "LPG/Propane") {
d$heat_ratio <- d$lpgprice / (d$hinc / 1e3)
out <- predict(lpg_model, newdata = d) * d$lpgprice
out <- cbind(out, d$LPG_cie)
}
if (d$hfuel[1] == "Heating oil") {
d$heat_ratio <- d$hoilprice / (d$hinc / 1e3)
out <- predict(hoil_model, newdata = d) * d$hoilprice
out <- cbind(out, d$Heating_oil_cie)
}
if (d$hfuel[1] %in% c("Electricity", "Other or none")) {
out <- matrix(rep(0, 3 * nrow(d)), ncol = 3)
}
out <- cbind(d$id, out)
colnames(out) <- c("id", "heat", "heat_upr", "heat_cie")
out[,c("heat", "heat_upr")] <- signif(out[,c("heat", "heat_upr")] / 12, 2)
return(out)
}
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- data.frame(do.call("rbind", heat))
heat <- heat[order(heat$id), -1]
#----------------------
# Carbon price ($ per ton CO2)
carbon.price <- 15
# Estimated 90% margin of error (in dollars, annual)
nd$moe <- round(1.645 * stdev * carbon.price)
# Annual cost equation
nd$cost <- paste(
round(core * carbon.price, 2),
paste0("gas * ", signif(52 * nd$Gasoline_cie * carbon.price / 1e3, 4)),
paste0("elec * ", signif(12 * nd$Electricity_cie * carbon.price / 1e3, 4)),
paste0("heat * ", signif(12 * heat$heat_cie * carbon.price / 1e3, 4)), sep = " + ")
# Return results matrix
psets <- cbind(gas, elec, heat)
psets[psets < 0] <- 0
result <- cbind(nd, psets)
result <- subset(result, select = c(div_pre, mrate, cost, moe, gas, elec, heat, gas_upr, elec_upr, heat_upr))
return(result)
}
require(quantreg)
predictModel(nd)
for (i in list.files("~/Documents/Projects/exampleR/data/", full.names = TRUE)) load(i)
predictModel(nd)
nd
p <- nd
p[p$hfuel == "Other or none"] <- "Natural gas"
q <- predict(core_model, newdata = p)
core <- q[,2]
stdev <- apply(q, 1, function(x) diff(x[c(1,3)])) / 1.35
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("rms" %in% nms)
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup, sort = FALSE)
nd <- nd[order(nd$id),]
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
div.adult <- 377
# #TO DO: Estimate household marginal tax rate
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
#nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd$np <- nd$na + nd$na
nd$elec_ratio <- nd$cents_kwh / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice / (nd$hinc / 1e3)
p <- nd
p[p$hfuel == "Other or none"] <- "Natural gas"
q <- predict(core_model, newdata = p)
core <- q[,2]
stdev <- apply(q, 1, function(x) diff(x[c(1,3)])) / 1.35
p
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7")
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup, sort = FALSE)
nd <- nd[order(nd$id),]
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
div.adult <- 377
# #TO DO: Estimate household marginal tax rate
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
#nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd$np <- nd$na + nd$na
nd$elec_ratio <- nd$cents_kwh / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice / (nd$hinc / 1e3)
nd
p <- nd
p[p$hfuel == "Other or none"] <- "Natural gas"
p
p <- nd
p[p$hfuel == "Other or none"] <- "Natural gas"
q <- predict(core_model, newdata = p)
core <- q[,2]
stdev <- apply(q, 1, function(x) diff(x[c(1,3)])) / 1.35
q
predictModel <- function(input) {
#input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input)
} else {
as.data.frame(input)
}
# Check that all necessary input variables are present
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("rms" %in% nms)
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup, sort = FALSE)
nd <- nd[order(nd$id),]
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
div.adult <- 377
# #TO DO: Estimate household marginal tax rate
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
#nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd$np <- nd$na + nd$na
nd$elec_ratio <- nd$cents_kwh / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice / (nd$hinc / 1e3)
#----------------------
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
p <- nd
p[p$hfuel == "Other or none"] <- "Natural gas"
q <- predict(core_model, newdata = p)
core <- q[,2]
stdev <- apply(q, 1, function(x) diff(x[c(1,3)])) / 1.35
#----------------------
# Gasoline weekly expenditure (median and 95th percentile)
gas <- signif(predict(gas_model, newdata = nd) * nd$gasprice / 52, digits = 2)
colnames(gas) <- c("gas", "gas_upr")
# Electricity monthly expenditure (median and 95th percentile)
elec <- signif(predict(elec_model, newdata = nd) * nd$cents_kwh / 12, digits = 2)
colnames(elec) <- c("elec", "elec_upr")
# Primary heating fuel monthly expenditure (median and 95th percentile)
predHeatModels <- function(d) {
if (d$hfuel[1] == "Natural gas") {
d$heat_ratio <- d$ngasprice / (d$hinc / 1e3)
out <- predict(ngas_model, newdata = d) * d$ngasprice
out <- cbind(out, d$Natural_gas_cie)
}
if (d$hfuel[1] == "LPG/Propane") {
d$heat_ratio <- d$lpgprice / (d$hinc / 1e3)
out <- predict(lpg_model, newdata = d) * d$lpgprice
out <- cbind(out, d$LPG_cie)
}
if (d$hfuel[1] == "Heating oil") {
d$heat_ratio <- d$hoilprice / (d$hinc / 1e3)
out <- predict(hoil_model, newdata = d) * d$hoilprice
out <- cbind(out, d$Heating_oil_cie)
}
if (d$hfuel[1] %in% c("Electricity", "Other or none")) {
out <- matrix(rep(0, 3 * nrow(d)), ncol = 3)
}
out <- cbind(d$id, out)
colnames(out) <- c("id", "heat", "heat_upr", "heat_cie")
out[,c("heat", "heat_upr")] <- signif(out[,c("heat", "heat_upr")] / 12, 2)
return(out)
}
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- data.frame(do.call("rbind", heat))
heat <- heat[order(heat$id), -1]
#----------------------
# Carbon price ($ per ton CO2)
carbon.price <- 15
# Estimated 90% margin of error (in dollars, annual)
nd$moe <- round(1.645 * stdev * carbon.price)
# Annual cost equation
nd$cost <- paste(
round(core * carbon.price, 2),
paste0("gas * ", signif(52 * nd$Gasoline_cie * carbon.price / 1e3, 4)),
paste0("elec * ", signif(12 * nd$Electricity_cie * carbon.price / 1e3, 4)),
paste0("heat * ", signif(12 * heat$heat_cie * carbon.price / 1e3, 4)), sep = " + ")
# Return results matrix
psets <- cbind(gas, elec, heat)
psets[psets < 0] <- 0
result <- cbind(nd, psets)
result <- subset(result, select = c(div_pre, mrate, cost, moe, gas, elec, heat, gas_upr, elec_upr, heat_upr))
return(result)
}
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7")
predictModel(nd)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7")
predictModel( data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7"))
predictModel( data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Other or none", veh = "2", rms = "7"))
