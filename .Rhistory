paste0("gas * ", signif(52 * nd$Gasoline_cie * carbon.price / 1e3, 4)),
paste0("elec * ", signif(12 * nd$Electricity_cie * carbon.price / 1e3, 4)),
paste0("heat * ", signif(12 * heat$heat_cie * carbon.price / 1e3, 4)), sep = " + ")
# Return results matrix
psets <- cbind(gas, elec, heat)
psets[psets < 0] <- 0
result <- cbind(nd, psets)
result <- subset(result, select = c(div_pre, mrate, cost, moe, gas, elec, heat, gas_upr, elec_upr, heat_upr))
result
library(exampleR)
# INPUT FOR TESTING:
for (i in list.files("~/Documents/Projects/exampleR/data/", full.names = TRUE)) load(i)
require(quantreg)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Other or none", veh = "2", rms = "7")
predictModel(nd)
nd
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Other or none", veh = "2", rms = "7", stringsAsFactors = FALSE)
predictModel(nd)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7", stringsAsFactors = FALSE)
predictModel(nd)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Other or none", veh = "2", rms = "7", stringsAsFactors = FALSE)
predictModel <- function(input) {
# Input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input, stringsAsFactors = FALSE)
} else {
as.data.frame(input, stringsAsFactors = FALSE)
}
# Check that all necessary input variables are present
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("rms" %in% nms)
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup, sort = FALSE)
nd <- nd[order(nd$id),]
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
div.adult <- 377
# #TO DO: Estimate household marginal tax rate
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
#nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd$np <- nd$na + nd$na
nd$elec_ratio <- nd$cents_kwh / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice / (nd$hinc / 1e3)
#----------------------
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
other.id <- which(nd$hfuel == "Other or none")
if (length(other.id) > 0) {
#nd$hfuel = as.character(nd$hfuel)
nd$hfuel[nd$hfuel == "Other or none"] <- "Natural gas"
}
q <- predict(core_model, newdata = nd)
core <- q[,2]
stdev <- apply(q, 1, function(x) diff(x[c(1,3)])) / 1.35
#----------------------
# Gasoline weekly expenditure (median and 95th percentile)
gas <- signif(predict(gas_model, newdata = nd) * nd$gasprice / 52, digits = 2)
colnames(gas) <- c("gas", "gas_upr")
# Electricity monthly expenditure (median and 95th percentile)
elec <- signif(predict(elec_model, newdata = nd) * nd$cents_kwh / 12, digits = 2)
colnames(elec) <- c("elec", "elec_upr")
# Primary heating fuel monthly expenditure (median and 95th percentile)
predHeatModels <- function(d) {
if (d$hfuel[1] == "Natural gas") {
d$heat_ratio <- d$ngasprice / (d$hinc / 1e3)
out <- predict(ngas_model, newdata = d) * d$ngasprice
out <- cbind(out, d$Natural_gas_cie)
}
if (d$hfuel[1] == "LPG/Propane") {
d$heat_ratio <- d$lpgprice / (d$hinc / 1e3)
out <- predict(lpg_model, newdata = d) * d$lpgprice
out <- cbind(out, d$LPG_cie)
}
if (d$hfuel[1] == "Heating oil") {
d$heat_ratio <- d$hoilprice / (d$hinc / 1e3)
out <- predict(hoil_model, newdata = d) * d$hoilprice
out <- cbind(out, d$Heating_oil_cie)
}
if (d$hfuel[1] %in% c("Electricity")) {
out <- matrix(rep(0, 3 * nrow(d)), ncol = 3)
}
out <- cbind(d$id, out)
colnames(out) <- c("id", "heat", "heat_upr", "heat_cie")
out[,c("heat", "heat_upr")] <- signif(out[,c("heat", "heat_upr")] / 12, 2)
return(out)
}
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- data.frame(do.call("rbind", heat))
heat <- heat[order(heat$id), -1]
heat[other.id,] <- 0  # Set heat-related variables to zero if original hfuel='Other or none'
#----------------------
# Carbon price ($ per ton CO2)
carbon.price <- 15
# Estimated 90% margin of error (in dollars, annual)
nd$moe <- round(1.645 * stdev * carbon.price)
# Annual cost equation
nd$cost <- paste(
round(core * carbon.price, 2),
paste0("gas * ", signif(52 * nd$Gasoline_cie * carbon.price / 1e3, 4)),
paste0("elec * ", signif(12 * nd$Electricity_cie * carbon.price / 1e3, 4)),
paste0("heat * ", signif(12 * heat$heat_cie * carbon.price / 1e3, 4)), sep = " + ")
# Return results matrix
psets <- cbind(gas, elec, heat)
psets[psets < 0] <- 0
result <- cbind(nd, psets)
result <- subset(result, select = c(div_pre, mrate, cost, moe, gas, elec, heat, gas_upr, elec_upr, heat_upr))
return(result)
}
predictModel(nd)
277/12
377/12
377/12*0.85
nd
d = nd
status <- rep("single", nrow(d))
status
status[d$nc > 0] <- "head"
status
nd <- rbind(nd, nd)
d=nd
nd
d
d$nc[2] = 0
d$na[2] = 1
status <- rep("single", nrow(d))
status[d$nc > 0] <- "head"
status[d$na >= 2] <- "married"
deps <- d$nc
status
d
deps <- d$nc + pmax(0, d$na - 2)
deps
deduct <- rep(6300, nrow(d))
deduct[d$nc > 0] <- 9300
deduct[d$na >= 2] <- 12600
deduct
deps <- d$nc + pmax(0, d$na - 2)
deps
deduct <- rep(6300, nrow(d))
deduct[d$nc > 0] <- 9300
deduct[d$na >= 2] <- 12600
exempt <- 4050 * (d$na + d$nc)
taxable.income <- d$hinc - deduct - exempt
deduct
taxable.income
?rate
?findInterval
findInterval(taxable.income, c(-Inf, 9275, 37650, 91150, 190150, 413350, 415050, Inf))
taxable <- d$hinc - deduct - exempt
deduct <- rep(6350, nrow(d))
deduct[d$nc > 0] <- 9350
deduct[d$na >= 2] <- 12700
exempt <- 4050 * (d$na + d$nc)
taxable <- d$hinc - deduct - exempt
# Identify marginal tax bracket based on 2016
rates <- c(0, 0.1, 0.15, 0.25, 0.28, 0.33, 0.35, 0.396)
mrate <- 0
mrate[deduct == 6350] <- findInterval(taxable[deduct == 6350], c(-Inf, 0, 9275, 37650, 91150, 190150, 413350, 415050, Inf))
mrate
mrate <- rates[mrate]
mrate
deduct <- rep(6350, nrow(d))
deduct[d$nc > 0] <- 9350
deduct[d$na >= 2] <- 12700
exempt <- 4050 * (d$na + d$nc)
taxable <- d$hinc - deduct - exempt
# Identify marginal tax bracket based on 2016
mrate <- 1
mrate[deduct == 6350] <- findInterval(taxable[deduct == 6350], c(-Inf, 0, 9275, 37650, 91150, 190150, 413350, 415050, Inf))
mrate
rates
rates <- c(0, 0.1, 0.15, 0.25, 0.28, 0.33, 0.35, 0.396)
mrate <- rates[mrate]
mrate
# Estimate standard deduction and exemptions
deduct <- rep(6350, nrow(d))
deduct[d$nc > 0] <- 9350
deduct[d$na >= 2] <- 12700
exempt <- 4050 * (d$na + d$nc)
# Calculate taxable income (assumes AGI = d$hinc)
taxable <- d$hinc - deduct - exempt
# Determine marginal Federal income tax rate
rates <- c(0, 0.1, 0.15, 0.25, 0.28, 0.33, 0.35, 0.396)
mrate <- 1
mrate[deduct == 6350] <- findInterval(taxable[deduct == 6350], c(-Inf, 0, 9325, 37950, 91900, 191650, 416700, 418400, Inf))
mrate[deduct == 9350] <- findInterval(taxable[deduct == 9350], c(-Inf, 0, 13350, 50800, 131200, 212500, 416700, 444500, Inf))
mrate[deduct == 12700] <- findInterval(taxable[deduct == 12700], c(-Inf, 0, 18650, 75900, 153100, 233350, 416700, 470700, Inf))
mrate <- rates[mrate]
mrate
d
taxable
margRate <- function(d) {
# Deductions, exemptions, and tax rates/brackets based on tax year 2017
# Source: https://taxfoundation.org/2017-tax-brackets/
# Estimate standard deduction and exemptions
deduct <- rep(6350, nrow(d))
deduct[d$nc > 0] <- 9350
deduct[d$na >= 2] <- 12700
exempt <- 4050 * (d$na + d$nc)
# Calculate taxable income (assumes AGI = d$hinc)
taxable <- d$hinc - deduct - exempt
# Determine marginal Federal income tax rate
rates <- c(0, 0.1, 0.15, 0.25, 0.28, 0.33, 0.35, 0.396)
mrate <- 1
mrate[deduct == 6350] <- findInterval(taxable[deduct == 6350], c(-Inf, 0, 9325, 37950, 91900, 191650, 416700, 418400, Inf))
mrate[deduct == 9350] <- findInterval(taxable[deduct == 9350], c(-Inf, 0, 13350, 50800, 131200, 212500, 416700, 444500, Inf))
mrate[deduct == 12700] <- findInterval(taxable[deduct == 12700], c(-Inf, 0, 18650, 75900, 153100, 233350, 416700, 470700, Inf))
mrate <- rates[mrate]
return(mrate)
}
predictModel <- function(input) {
# Input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input, stringsAsFactors = FALSE)
} else {
as.data.frame(input, stringsAsFactors = FALSE)
}
# Check that all necessary input variables are present
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("rms" %in% nms)
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup, sort = FALSE)
nd <- nd[order(nd$id),]
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
div.adult <- 377
# #TO DO: Estimate household marginal tax rate
nd$mrate <- margRate(nd)
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
#nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd$np <- nd$na + nd$na
nd$elec_ratio <- nd$cents_kwh / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice / (nd$hinc / 1e3)
#----------------------
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
other.id <- which(nd$hfuel == "Other or none")
if (length(other.id) > 0) {
#nd$hfuel = as.character(nd$hfuel)
nd$hfuel[nd$hfuel == "Other or none"] <- "Natural gas"
}
q <- predict(core_model, newdata = nd)
core <- q[,2]
stdev <- apply(q, 1, function(x) diff(x[c(1,3)])) / 1.35
#----------------------
# Gasoline weekly expenditure (median and 95th percentile)
gas <- signif(predict(gas_model, newdata = nd) * nd$gasprice / 52, digits = 2)
colnames(gas) <- c("gas", "gas_upr")
# Electricity monthly expenditure (median and 95th percentile)
elec <- signif(predict(elec_model, newdata = nd) * nd$cents_kwh / 12, digits = 2)
colnames(elec) <- c("elec", "elec_upr")
# Primary heating fuel monthly expenditure (median and 95th percentile)
predHeatModels <- function(d) {
if (d$hfuel[1] == "Natural gas") {
d$heat_ratio <- d$ngasprice / (d$hinc / 1e3)
out <- predict(ngas_model, newdata = d) * d$ngasprice
out <- cbind(out, d$Natural_gas_cie)
}
if (d$hfuel[1] == "LPG/Propane") {
d$heat_ratio <- d$lpgprice / (d$hinc / 1e3)
out <- predict(lpg_model, newdata = d) * d$lpgprice
out <- cbind(out, d$LPG_cie)
}
if (d$hfuel[1] == "Heating oil") {
d$heat_ratio <- d$hoilprice / (d$hinc / 1e3)
out <- predict(hoil_model, newdata = d) * d$hoilprice
out <- cbind(out, d$Heating_oil_cie)
}
if (d$hfuel[1] %in% c("Electricity")) {
out <- matrix(rep(0, 3 * nrow(d)), ncol = 3)
}
out <- cbind(d$id, out)
colnames(out) <- c("id", "heat", "heat_upr", "heat_cie")
out[,c("heat", "heat_upr")] <- signif(out[,c("heat", "heat_upr")] / 12, 2)
return(out)
}
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- data.frame(do.call("rbind", heat))
heat <- heat[order(heat$id), -1]
heat[other.id,] <- 0  # Set heat-related variables to zero if original hfuel='Other or none'
#----------------------
# Carbon price ($ per ton CO2)
carbon.price <- 15
# Estimated 90% margin of error (in dollars, annual)
nd$moe <- round(1.645 * stdev * carbon.price)
# Annual cost equation
nd$cost <- paste(
round(core * carbon.price, 2),
paste0("gas * ", signif(52 * nd$Gasoline_cie * carbon.price / 1e3, 4)),
paste0("elec * ", signif(12 * nd$Electricity_cie * carbon.price / 1e3, 4)),
paste0("heat * ", signif(12 * heat$heat_cie * carbon.price / 1e3, 4)), sep = " + ")
# Return results matrix
psets <- cbind(gas, elec, heat)
psets[psets < 0] <- 0
result <- cbind(nd, psets)
result <- subset(result, select = c(div_pre, mrate, cost, moe, gas, elec, heat, gas_upr, elec_upr, heat_upr))
return(result)
}
nd
nd <- data.frame(zip = c("94062","80524"), na = c(2, 1), nc = c(2, 0), hinc = c(50e3, 300e3), hfuel = c("Electricity", "Natural gas"), veh = c("2", "1"), rms = c("7", "5"), stringsAsFactors = FALSE)
nd
predictModel(d)
3e+05
3e+05/100e3
predictModel(nd)
?margRAte
?predictModel
roxygen2::roxygenise()
library(exampleR)
?margRate
roxygen2::roxygenise()
?margRate
library(exampleR)
?margRate
margRate(d)
roxygen2::roxygenise()
library(exampleR)
?margRate
roxygen2::roxygenise()
library(exampleR)
nd
predictModel(nd)
377*0.666/12
377*(1-033)/12
377*(1-0.33)/12
x <- seq(1, 400e3, length.out = 100)
plot(log(x), x)
?log2
x <- seq(1, 400e3, length.out = 100)
plot(log(x), x)
lines(log2(x), x, col = 2)
lines(log10(x), x, col = 3)
x <- seq(1, 400e3, length.out = 100)
y <- log2(x)
y
library(scales)
y <- rescale(y, 1, 100)
plot(y, x)
y
rescale(
?rescale
)
?rescale
y <- seq(1, 400e3, length.out = 100)
x <- log2(x)
x <- rescale(x, c(1, 100))
plot(x, y, type = "l")
y <- seq(1, 400e3, length.out = 100)
x <- log(x)
x <- rescale(x, c(1, 100))
plot(x, y, type = "l")
y
x
which(x==80)
y <- seq(1, 400e3, length.out = 100)
x <- log2(x)
x <- rescale(x, c(1, 100))
plot(x, y, type = "l")
which(x==80)
x
y <- seq(1, 400e3, length.out = 100)
x <- log2(x)
x <- rescale(x, c(1, 100))
plot(x, y, type = "l")
y <- seq(1, 400e3, length.out = 100)
x <- log2(x)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
x
y <- seq(1, 400e3, length.out = 100)
x <- log(x)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
y <- seq(1, 400e3, length.out = 100)
x <- log2(x)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
x
?log
y <- seq(1, 400e3, length.out = 100)
x <- log(x, 1)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
y <- seq(1, 400e3, length.out = 100)
x <- log(x, 1.5)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
x
y <- seq(1, 400e3, length.out = 100)
x <- log2(y)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
y <- seq(1, 400e3, length.out = 100)
x <- log(y)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
y <- seq(1, 400e3, length.out = 100)
x <- log2(y)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
y <- seq(1, 400e3, length.out = 100)
x <- log(y)
x <- rescale(x, c(0, 100))
plot(x, y, type = "l")
log(y)
log2(y)
rescale(log2(y), c(0, 100))
rescale(log(y), c(0, 100))
?log2
exp(1)
y <- seq(6e3, 400e3, length.out = 100)
x <- rescale(log2(y), c(0, 100))
y
x
?reacle
log2(y)
log(y)
plot(log(y))
plot(log2(y))
plot(log(y, 10))
plot(sqrt(y)
)
y <- seq(6e3, 400e3, length.out = 100)
x <- rescale(log(y), c(0, 100))
plot(x, y, type = "l")
y <- seq(6e3, 400e3, length.out = 100)
x <- rescale(sqrt(y), c(0, 100))
plot(x, y, type = "l")
4^3
y
x[12]
y <- seq(6e3, 400e3, length.out = 100)
x <- rescale(y^1.5, c(0, 100))
plot(x, y, type = "l")
y <- seq(6e3, 400e3, length.out = 100)
x <- rescale(log(y), c(0, 100))
plot(x, y, type = "l")
y
x[12]
x
y <- seq(6e3, 400e3, length.out = 100)
x <- rescale(log(y), c(0, 100))
plot(x, y, type = "l")
y
x
x[12]
x[50]
y <- seq(6e3, 400e3, length.out = 100)
x <- rescale(log(y), c(0, 100))
plot(x, y, type = "l")
x[12]
y <- seq(5e3, 400e3, length.out = 100)
x <- rescale(log(y), c(0, 100))
y
x[13]
minp = 0
maxp = 100
minv = log(6000)
maxv = log(400000)
scale = (maxv-minv) / (maxp-minp)
scale
exp(minv + scale*(position-minp))
f <- function(position) {
minp = 0
maxp = 100
minv = log(6000)
maxv = log(400000)
scale = (maxv-minv) / (maxp-minp)
exp(minv + scale*(position-minp))
}
f(50)
f <- function(position) {
minp = 0
maxp = 100
minv = log(5000)
maxv = log(400000)
scale = (maxv-minv) / (maxp-minp)
exp(minv + scale*(position-minp))
}
f(50)
f(75)
f(100)
f(25)
