nd$div_pre <- div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors)
nd$div_post <- nd$div_pre * (1 - nd$mrate)
# Predict the cost
#nd$cost <- as.vector(predict.gbm(fitted_model, newdata = nd, n.trees = fitted_model$n.trees))
#nd$net <- nd$div_post - nd$cost
#------
# How does variation in income affect the result
test <- plot.gbm(fitted_model, i.var = c("income", "elec"), n.trees = fitted_model$n.trees, return.grid = TRUE, continuous.resolution = 50)
# pred <- setdiff(names(test), "y")
#
# fit0 <- lm(y ~ ., data = test)
#
# fit0 <- lm(y ~ poly(income, 1, raw = T) * poly(elec, 1, raw = T), data = test)
f <- "y ~ income + elec + income:elec"
fit0 <- lm(formula = formula(f), data = test)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
m <- prettyNum(signif(coef(fit0), 4))
names(m)[1] <- "1"
eq <- gsub(":", " * ", paste(sprintf("%s * %s", m, names(m)), collapse = " + "))
#fit <- lm(formula = formula(paste0("y ~ ", paste0("poly(", pred, ", degree = 3, raw = TRUE)"))), data = test)
#fit2 <- as.stepfun(isoreg(x = test$income, y = test$y))
#library(MonoPoly)
#fit3 <- monpol(y ~income, data = test, degree = 5, monotone = "increasing")
# Check fit
# plot(test)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 2)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 3)
#-----
out <- subset(nd, select = c(mrate, div_pre, div_post))
out$eq = eq
out
m <- prettyNum(signif(coef(fit0), 4))
names(m)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", m, names(m)), collapse = " + ")))
prettyNum()
?prettyNum
m <- prettyNum(signif(coef(fit0), 4))
names(m)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", m, names(m)), collapse = " + ")))
eq
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", m, names(m)), collapse = " + ")), fixed = TRUE)
eq
nd
out
nd
#out <- subset(nd, select = c(mrate, div_pre, div_post))
nd$cost <- eq
nd
View(nd)
out <- subset(nd, select = c(mrate, div_pre, div_post))
out$cost <- eq
out
pred
library(gbm)
library(tidyverse)
d <- read_rds("~/Documents/Projects/CCL/Data/Results/Policy simulation results by household.rds")
# Temporary: Using total utilities expenditure at household level to proxy for monthly electricity expenditure
elec <- read_rds("~/Documents/Projects/CCL/Data/Results/Household category expenditure and emissions 2012.rds") %>%
filter(cat == "Utilities", year == 2012, expend > 0) %>%
mutate(elec = expend * 1400 / mean(expend),
elec = elec / 12) %>%  # Call the variable electricity and set the mean to around 1400 per year
select(id, elec)
# Adult pre-tax dividend amount
filter(d, np == 1, nc == 0)$div_pre[1]
# Fit GBM model predicting cost_co2, based on following user inputs:
# State of residence
# Household size
# Number of minors
# Age of householder
# Household income (slider variable)
# Rent expenditure (slider variable)
dset <- d %>%
filter(year == 2012) %>%
rename(state = state.name, hhsize = np, minors = nc, income = hinc) %>%
mutate(state = factor(state)) %>%
inner_join(elec) %>%
filter(income > 0, income < quantile(income, 0.95), elec < quantile(elec, 0.95)) %>%  # Restrict income and electricity expenditure within reasonable bounds
select(hw, state, hhsize, minors, age, income, elec, cost_co2) %>%
sample_frac(0.05)
# Create vector of predictor variables
pred <- setdiff(names(dset), c("hw", "cost_co2"))
# Vector giving the var.monotone integer (-1, 0, 1) for each predictor variable
# Zero (no relationship) is the default
mono <- rep(0, length(pred))
mono[which(pred %in% c("income", "elec"))] <- 1
#----------
# Fit GBM model #0
# This model uses the full set of predictors
fitted_model0 <- gbm(formula = formula(paste0("cost_co2 ~ ", paste(pred, collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model0, file = "data/fitted_model0.rda")
#----------
# Fit GBM model #1 - income
# This model uses ONLY the non-slider predictors
# Slider predictors are assumed to be those where 'mono' == 1
fitted_model1 <- gbm(formula = formula(paste0("income ~ ", paste(pred[mono != 1], collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
#var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model1, file = "data/fitted_model1.rda")
# Fit GBM model #2 - elec
# This model uses ONLY the non-slider predictors
# Slider predictors are assumed to be those where 'mono' == 1
fitted_model2 <- gbm(formula = formula(paste0("elec ~ ", paste(pred[mono != 1], collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
#var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model2, file = "data/fitted_model2.rda")
rm(fitted_model)
pred
# Testing:
#nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 50e3, elec = 100)
nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate the input data marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate post-tax dividend
nd$div_pre <- div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors)
nd$div_post <- nd$div_pre * (1 - nd$mrate)
# Predict the cost
#nd$cost <- as.vector(predict.gbm(fitted_model, newdata = nd, n.trees = fitted_model$n.trees))
#nd$net <- nd$div_post - nd$cost
nd
?assign
ls(pattern = "fitted_model")
?ls
smodels <- ls(pattern = "fitted_model")[-1]
smodels
nd
x=smodels[1]
x
m <- get(x)
m
m$Terms
str(m)
m$response.name
nd[[m$response.name]] <- predict.gbm(m, newdata = nd, n.trees = m$n.trees)
nd
for (x in ls(pattern = "fitted_model")[-1]) {
m <- get(x)
nd[[m$response.name]] <- predict.gbm(m, newdata = nd, n.trees = m$n.trees)
}
nd
rm(test)
# How does variation in income affect the result
slide <- plot.gbm(fitted_model0, i.var = c("income", "elec"), n.trees = fitted_model$n.trees, return.grid = TRUE, continuous.resolution = 50)
f <- "y ~ income + elec + income:elec"
fit0 <- lm(formula = formula(f), data = slide)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
m <- prettyNum(signif(coef(fit0), 4))
names(m)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", m, names(m)), collapse = " + ")), fixed = TRUE)
#------
# pred <- setdiff(names(test), "y")
# fit0 <- lm(y ~ ., data = test)
# fit0 <- lm(y ~ poly(income, 1, raw = T) * poly(elec, 1, raw = T), data = test)
#fit <- lm(formula = formula(paste0("y ~ ", paste0("poly(", pred, ", degree = 3, raw = TRUE)"))), data = test)
#fit2 <- as.stepfun(isoreg(x = test$income, y = test$y))
#library(MonoPoly)
#fit3 <- monpol(y ~income, data = test, degree = 5, monotone = "increasing")
# Check fit
# plot(test)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 2)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 3)
#-----
out <- subset(nd, select = c(mrate, div_pre, div_post))
out$cost <- eq
out
#out <- subset(nd, select = c(mrate, div_pre, div_post))
out <- nd
out$cost <- eq
out
View(out)
out <- subset(nd, select = c(mrate, div_pre, div_post))
out$cost <- eq
out
nd
#nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 50e3, elec = 100)
nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#------
# Predict the slider preset values
for (x in ls(pattern = "fitted_model")[-1]) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
#------
# How does variation in income affect the result
slide <- plot.gbm(fitted_model0, i.var = c("income", "elec"), n.trees = fitted_model$n.trees, return.grid = TRUE, continuous.resolution = 50)
f <- "y ~ income + elec + income:elec"
fit0 <- lm(formula = formula(f), data = slide)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
m <- prettyNum(signif(coef(fit0), 4))
names(m)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", m, names(m)), collapse = " + ")), fixed = TRUE)
#------
# pred <- setdiff(names(test), "y")
# fit0 <- lm(y ~ ., data = test)
# fit0 <- lm(y ~ poly(income, 1, raw = T) * poly(elec, 1, raw = T), data = test)
#fit <- lm(formula = formula(paste0("y ~ ", paste0("poly(", pred, ", degree = 3, raw = TRUE)"))), data = test)
#fit2 <- as.stepfun(isoreg(x = test$income, y = test$y))
#library(MonoPoly)
#fit3 <- monpol(y ~income, data = test, degree = 5, monotone = "increasing")
# Check fit
# plot(test)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 2)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 3)
#-----
out <- subset(nd, select = c(mrate, div_pre, div_post))
out$cost <- eq
out$eq
out$cost
1131*(1-0.15)
nd
d <- read_rds("~/Documents/Projects/CCL/Data/Spatial/ZCTA 2010 with state identifiers.rds")
dim(d)
head(d)
head(d@data)
g <- read_csv("~/Documents/Projects/CCL/Data/Spatial/Master State-Region Concordance File.csv")
dim(g)
head(g)
head(d)
head(d@data)
head(g)
pred
select(zip5, state_fips) %>%
filter(!duplicated(zip)) %>%
inner_join(select(g, st, state.name)))
select(zip5, state_fips) %>%
filter(!duplicated(zip)) %>%
inner_join(select(g, st, state.name))
head(d)
head(d@data)
head(g)
zip <- d@data %>%
rename(st = state_fips) %>%
select(zip5, state_fips) %>%
filter(!duplicated(zip)) %>%
inner_join(select(g, st, state.name))
zip <- d@data %>%
rename(st = state_fips)
zip <- d@data %>%
rename(st = state_fips) %>%
select(zip5, st) %>%
filter(!duplicated(zip)) %>%
inner_join(select(g, st, state.name))
head(zip)
zip_lookup <- d@data %>%
rename(st = state_fips) %>%
select(zip5, st) %>%
filter(!duplicated(zip)) %>%
inner_join(select(g, st, state.name)) %>%
select(zip5, state.name) %>%
rename(zip = zip5, state = state.name)
dim(zip_lookup)
head(zip_lookup)
head(duplicated(zip_lookup$zip))
zip_lookup <- d@data %>%
rename(st = state_fips) %>%
select(zip5, st) %>%
filter(!duplicated(zip5)) %>%
inner_join(select(g, st, state.name)) %>%
select(zip5, state.name) %>%
rename(zip = zip5, state = state.name)
head(zip_lookup)
# Save model object to disk as .rda object
save(zip_lookupo, file = "data/zip_lookup.rda")
# Save model object to disk as .rda object
save(zip_lookup, file = "data/zip_lookup.rda")
pred
head(zip_lookup)
View(zip_lookup)
class(zip_lookup$zip)
# Testing:
#nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 50e3, elec = 100)
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
nd
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
for (x in ls(pattern = "fitted_model")[-1]) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
nd
?data
data()
class(data())
as.vector(data())
str(data())
data(package = .packages(all.available = TRUE))
ls("/Data")
ls("data")
ls("/data")
?ls
list.files("data")
head(nd)
#nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 50e3, elec = 100)
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd
ls(pattern = "fitted_model")
for (x in ls(pattern = "fitted_model")[-1]) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
nd
#nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 50e3, elec = 100)
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
nd
x in ls(pattern = "fitted_model")[-1][1]
x
x
m <- get(x)
predict.gbm(m, newdata = nd, n.trees = m$n.trees)
class(nd$state)
zip_lookup <- d@data %>%
rename(st = state_fips) %>%
select(zip5, st) %>%
filter(!duplicated(zip5)) %>%
inner_join(select(g, st, state.name)) %>%
select(zip5, state.name) %>%
rename(zip = zip5, state = factor(state.name))
d <- read_rds("~/Documents/Projects/CCL/Data/Spatial/ZCTA 2010 with state identifiers.rds")
g <- read_csv("~/Documents/Projects/CCL/Data/Spatial/Master State-Region Concordance File.csv")
zip_lookup <- d@data %>%
rename(st = state_fips) %>%
select(zip5, st) %>%
filter(!duplicated(zip5)) %>%
inner_join(select(g, st, state.name)) %>%
select(zip5, state.name) %>%
rename(zip = zip5, state = factor(state.name))
# Save model object to disk as .rda object
save(zip_lookup, file = "data/zip_lookup.rda")
zip_lookup <- d@data %>%
rename(st = state_fips) %>%
select(zip5, st) %>%
filter(!duplicated(zip5)) %>%
inner_join(select(g, st, state.name)) %>%
rename(zip = zip5) %>%
mutate(state = factor(state.name)) %>%
select(zip5, state)
zip_lookup <- d@data %>%
rename(st = state_fips) %>%
select(zip5, st) %>%
filter(!duplicated(zip5)) %>%
inner_join(select(g, st, state.name)) %>%
rename(zip = zip5) %>%
mutate(state = factor(state.name)) %>%
select(zip, state)
head(zip_looku)
head(zip_lookup)
# Save model object to disk as .rda object
save(zip_lookup, file = "data/zip_lookup.rda")
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
class(nd$state)
predict.gbm(m, newdata = nd, n.trees = m$n.trees)
for (x in ls(pattern = "fitted_model")[-1]) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
?merge
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#------
# Predict the slider preset values
for (x in ls(pattern = "fitted_model")[-1]) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
#------
# How does variation in income affect the result
slide <- plot.gbm(fitted_model0, i.var = c("income", "elec"), n.trees = fitted_model$n.trees, return.grid = TRUE, continuous.resolution = 50)
f <- "y ~ income + elec + income:elec"
fit0 <- lm(formula = formula(f), data = slide)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
m <- prettyNum(signif(coef(fit0), 4))
names(m)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", m, names(m)), collapse = " + ")), fixed = TRUE)
#------
# pred <- setdiff(names(test), "y")
# fit0 <- lm(y ~ ., data = test)
# fit0 <- lm(y ~ poly(income, 1, raw = T) * poly(elec, 1, raw = T), data = test)
#fit <- lm(formula = formula(paste0("y ~ ", paste0("poly(", pred, ", degree = 3, raw = TRUE)"))), data = test)
#fit2 <- as.stepfun(isoreg(x = test$income, y = test$y))
#library(MonoPoly)
#fit3 <- monpol(y ~income, data = test, degree = 5, monotone = "increasing")
# Check fit
# plot(test)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 2)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 3)
#-----
out <- subset(nd, select = c(mrate, div_pre, div_post))
out$cost <- eq
out
summary(fitted_model0)
summary(fitted_model1)
summary(fitted_model2)
?roxygen
library(roxygen)
library(roxygen2)
?rosygen2
?roxygen2
roxygenize()
roxygenize()
?importFrom
library(exampleR)
library(exampleR)
pred
library(exampleR)
input <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50)
predictModel(input)
library(exampleR)
input
predictModel(input)
out
library(exampleR)
library(exampleR)
roxygen2::roxygenise()
library(exampleR)
input <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50)
predictModel(input)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#------
# Predict the slider preset values
for (x in ls(pattern = "fitted_model")[-1]) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
nd
library(exampleR)
ls()
