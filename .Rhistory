# Assign geographic variables to 'nd' using zip code provided
# If statement used to allow testing with the original dataset (which contains spatial variables but not zip code)
if (!test) {
nd <- merge(nd, zip_lookup, sort = FALSE)
}
# Assign price adjustment factors based on assigned state
# If statement used to allow testing with the original dataset (no price adjustments necessary)
if (!test) {
nd <- merge(nd, price_adjustment, sort = FALSE)
} else {
temp <- price_adjustment
temp[,-1] <- 1
nd <- merge(nd, temp, sort = FALSE)
}
# Ensure that original order to maintained; probably not necessry is sort = FALSE in merge()
nd <- nd[order(nd$id),]
# Estimate household marginal tax rate
# This is based on 2017 rates and brackets using household income as reported as user
nd$mrate <- margRate(nd)
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
# NOTE: This is NOT adjusted for inflation
# Total revenue in analysis assumes $15 per ton at 2012 emission levels; $377 is based on those assumptions
div.adult <- 377
# Calculate pre-tax dividend amount, adjusted to current dollars
if (!test) {
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
} else {
# The "nc - 1" is necessary to account for fact that test dataset added 1 to both 'nc' and 'veh' to avoid errors with log() in model formulas
# Rounding necessary to account for jitter added to test dataset numeric variables
nd$div_pre <- round(div.adult * round(nd$na) + 0.5 * div.adult * pmin(2, round(nd$nc - 1)))
}
# Fuel-price-to-income ratios used in model fitting
# Note that fuel prices are adjusted from 2012 to current price levels
# If statement will skip this is using test dataset (elec_ratio and gas_ratio already in the data frame)
if (!test) {
nd$elec_ratio <- nd$cents_kwh * nd$elec_adjust / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice * nd$gas_adjust / (nd$hinc / 1e3)
}
# Deflate user input household income to 2012 levels using CPI
# This ensures that income matches currency units of original data and models
nd$hinc <- nd$hinc / nd$cpi_adjust
# Add 1 to 'nc' and 'veh' to allow log() calls in model prediction
# Not necessary when test dataset is being used
if (!test) {
nd$nc <- nd$nc + 1
nd$veh <- nd$veh + 1
}
# Total number of people in household
# Necessary to subtract 1 to account for addition to 'nc' immediately above
nd$np <- nd$na + nd$nc - 1
sapply(nd, class)
# Convert state, loc, and htype variables to factor
# predict.gam() now throws error if input variable types to do not match those used to fit model
for (i in c('state', 'loc', 'hytpe')) nd[[i]] <- factor(nd[[[i]]])
# Convert state, loc, and htype variables to factor
# predict.gam() now throws error if input variable types to do not match those used to fit model
for (i in c('state', 'loc', 'hytpe')) nd[[i]] <- factor(nd[[i]])
nd
i
nd[[i]]
class(nd)
nd[i]
i
nd$htype
class(nd)
i
nd[[i]]
nd[,i]
i
# Convert state, loc, and htype variables to factor
# predict.gam() now throws error if input variable types to do not match those used to fit model
for (i in c('state', 'loc', 'htype')) nd[[i]] <- factor(nd[[i]])
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
other.id <- which(nd$hfuel == "Other or none")
if (length(other.id) > 0) {
nd$hfuel[other.id] <- "Natural gas"
}
# If user does not know heating fuel, make a guess
# Fitted GLM model returns probability of Natural gas; Electricity otherwise (only two options)
donotknow.id <- which(nd$hfuel == "Do not know")
if (length(donotknow.id) > 0) {
pred <- stats::predict.glm(hfuel_model, newdata = nd[donotknow.id,])
# Convert from original scale to class probability (probability of Natural gas)
# https://stats.stackexchange.com/questions/164648/output-of-logistic-regression-prediction
prob <- exp(pred) / (1 + exp(pred))
nd$hfuel[donotknow.id] <- ifelse(prob >= 0.5, "Natural gas", "Electricity")
}
# Estimate core emissions and associated standard deviation, assuming Normal distribution
# Note exp() used to convert log prediction value
core <- as.numeric(exp(mgcv::predict.gam(core_model_gam, newdata = nd)))
q <- exp(quantreg::predict.rq(core_model_rq, newdata = nd))
if (nrow(nd) == 1) {
stdev <- (q[2] - q[1]) / 1.35
} else {
stdev <- (q[,2] - q[,1]) / 1.35
}
#----------------------
# Predict typical (mean) and upper-bound (approximately 97.5th percentile) expenditure values used to set the "page 2" slider preset and maximum value
# Note that all dollar values are adjusted to reflect current price levels ("_adjust" variables)
# Gasoline monthly expenditure (mean and approximately 97.5th percentile)
gas <- cbind(mgcv::predict.gam(gas_model_gam, newdata = nd), 1.1 * quantreg::predict.rq(gas_model_rq, newdata = nd))
gas <- signif(gas * nd$gas_adjust * nd$gasprice / 12, digits = 2)
#gas <- signif(predict(gas_model, newdata = nd) * nd$gas_adjust * nd$gasprice / 52, digits = 2)
colnames(gas) <- c("gas", "gas_upr")
gas[which(nd$veh == 1), "gas"] <- 0  # Set predicted gasoline expenditure to zero if user inputs zero vehicles (which is actually "1" in nd$veh after +1 to original value (above)
?predict.gam
# Estimate core emissions and associated standard deviation, assuming Normal distribution
# Note exp() used to convert log prediction value
core <- as.numeric(exp(mgcv::predict.gam(core_model_gam, newdata = nd)))
core
nd
nd = input
# Input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input, stringsAsFactors = FALSE)
} else {
as.data.frame(input, stringsAsFactors = FALSE)
}
# Check that all necessary input variables are present
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("htype" %in% nms)
# Detect if the input is a test dataset
# If the original training data is submitted, all 'zip' values will be NA
test <- all(is.na(nd$zip))
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
# If statement used to allow testing with the original dataset (which contains spatial variables but not zip code)
if (!test) {
nd <- merge(nd, zip_lookup, sort = FALSE)
}
# Assign price adjustment factors based on assigned state
# If statement used to allow testing with the original dataset (no price adjustments necessary)
if (!test) {
nd <- merge(nd, price_adjustment, sort = FALSE)
} else {
temp <- price_adjustment
temp[,-1] <- 1
nd <- merge(nd, temp, sort = FALSE)
}
# Ensure that original order to maintained; probably not necessry is sort = FALSE in merge()
nd <- nd[order(nd$id),]
# Estimate household marginal tax rate
# This is based on 2017 rates and brackets using household income as reported as user
nd$mrate <- margRate(nd)
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
# NOTE: This is NOT adjusted for inflation
# Total revenue in analysis assumes $15 per ton at 2012 emission levels; $377 is based on those assumptions
div.adult <- 377
# Calculate pre-tax dividend amount, adjusted to current dollars
if (!test) {
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
} else {
# The "nc - 1" is necessary to account for fact that test dataset added 1 to both 'nc' and 'veh' to avoid errors with log() in model formulas
# Rounding necessary to account for jitter added to test dataset numeric variables
nd$div_pre <- round(div.adult * round(nd$na) + 0.5 * div.adult * pmin(2, round(nd$nc - 1)))
}
# Fuel-price-to-income ratios used in model fitting
# Note that fuel prices are adjusted from 2012 to current price levels
# If statement will skip this is using test dataset (elec_ratio and gas_ratio already in the data frame)
if (!test) {
nd$elec_ratio <- nd$cents_kwh * nd$elec_adjust / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice * nd$gas_adjust / (nd$hinc / 1e3)
}
# Deflate user input household income to 2012 levels using CPI
# This ensures that income matches currency units of original data and models
nd$hinc <- nd$hinc / nd$cpi_adjust
# Add 1 to 'nc' and 'veh' to allow log() calls in model prediction
# Not necessary when test dataset is being used
if (!test) {
nd$nc <- nd$nc + 1
nd$veh <- nd$veh + 1
}
# Total number of people in household
# Necessary to subtract 1 to account for addition to 'nc' immediately above
nd$np <- nd$na + nd$nc - 1
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
other.id <- which(nd$hfuel == "Other or none")
if (length(other.id) > 0) {
nd$hfuel[other.id] <- "Natural gas"
}
# If user does not know heating fuel, make a guess
# Fitted GLM model returns probability of Natural gas; Electricity otherwise (only two options)
donotknow.id <- which(nd$hfuel == "Do not know")
if (length(donotknow.id) > 0) {
pred <- stats::predict.glm(hfuel_model, newdata = nd[donotknow.id,])
# Convert from original scale to class probability (probability of Natural gas)
# https://stats.stackexchange.com/questions/164648/output-of-logistic-regression-prediction
prob <- exp(pred) / (1 + exp(pred))
nd$hfuel[donotknow.id] <- ifelse(prob >= 0.5, "Natural gas", "Electricity")
}
# Estimate core emissions and associated standard deviation, assuming Normal distribution
# Note exp() used to convert log prediction value
core <- as.numeric(exp(mgcv::predict.gam(core_model_gam, newdata = nd)))
q <- exp(quantreg::predict.rq(core_model_rq, newdata = nd))
if (nrow(nd) == 1) {
stdev <- (q[2] - q[1]) / 1.35
} else {
stdev <- (q[,2] - q[,1]) / 1.35
}
core
nd
class(nd$loc)
class(nd$state)
mgcv::predict.gam(gas_model_gam, newdata = nd)
mgcv::predict.gam(gas_model_gam, newdata = nd, newdata.guaranteed = TRUE)
gas_model_gam
core_model_gam$xlevels
gas_model_gam$xlevels
quantreg::predict.rq(gas_model_rq, newdata = nd)
?predict
str(gas_model_rq)
core_model_rq
str(core_model_rq)
str(gas_model_rq)
nd <- data.frame(zip = c("94062","80524","70032"), na = c(2, 1, 3), nc = c(2, 0, 3), hinc = c(50e3, 300e3, 100e3), hfuel = c("Do not know", "Natural gas", "Other or none"), veh = c(2, 0, 3), htype = c("Stand-alone house", "Apartment building", "Other"), stringsAsFactors = FALSE)
input = nd
# Input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input, stringsAsFactors = FALSE)
} else {
as.data.frame(input, stringsAsFactors = FALSE)
}
# Check that all necessary input variables are present
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("htype" %in% nms)
# Detect if the input is a test dataset
# If the original training data is submitted, all 'zip' values will be NA
test <- all(is.na(nd$zip))
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
# If statement used to allow testing with the original dataset (which contains spatial variables but not zip code)
if (!test) {
nd <- merge(nd, zip_lookup, sort = FALSE)
}
# Assign price adjustment factors based on assigned state
# If statement used to allow testing with the original dataset (no price adjustments necessary)
if (!test) {
nd <- merge(nd, price_adjustment, sort = FALSE)
} else {
temp <- price_adjustment
temp[,-1] <- 1
nd <- merge(nd, temp, sort = FALSE)
}
# Ensure that original order to maintained; probably not necessry is sort = FALSE in merge()
nd <- nd[order(nd$id),]
# Estimate household marginal tax rate
# This is based on 2017 rates and brackets using household income as reported as user
nd$mrate <- margRate(nd)
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
# NOTE: This is NOT adjusted for inflation
# Total revenue in analysis assumes $15 per ton at 2012 emission levels; $377 is based on those assumptions
div.adult <- 377
# Calculate pre-tax dividend amount, adjusted to current dollars
if (!test) {
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
} else {
# The "nc - 1" is necessary to account for fact that test dataset added 1 to both 'nc' and 'veh' to avoid errors with log() in model formulas
# Rounding necessary to account for jitter added to test dataset numeric variables
nd$div_pre <- round(div.adult * round(nd$na) + 0.5 * div.adult * pmin(2, round(nd$nc - 1)))
}
# Fuel-price-to-income ratios used in model fitting
# Note that fuel prices are adjusted from 2012 to current price levels
# If statement will skip this is using test dataset (elec_ratio and gas_ratio already in the data frame)
if (!test) {
nd$elec_ratio <- nd$cents_kwh * nd$elec_adjust / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice * nd$gas_adjust / (nd$hinc / 1e3)
}
# Deflate user input household income to 2012 levels using CPI
# This ensures that income matches currency units of original data and models
nd$hinc <- nd$hinc / nd$cpi_adjust
# Add 1 to 'nc' and 'veh' to allow log() calls in model prediction
# Not necessary when test dataset is being used
if (!test) {
nd$nc <- nd$nc + 1
nd$veh <- nd$veh + 1
}
# Total number of people in household
# Necessary to subtract 1 to account for addition to 'nc' immediately above
nd$np <- nd$na + nd$nc - 1
#----------------------
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
other.id <- which(nd$hfuel == "Other or none")
if (length(other.id) > 0) {
nd$hfuel[other.id] <- "Natural gas"
}
other.id
donotknow.id <- which(nd$hfuel == "Do not know")
donotknow.i
donotknow.id
nd
pred <- stats::predict.glm(hfuel_model, newdata = nd[donotknow.id,])
predictModel <- function(input) {
# Input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input, stringsAsFactors = FALSE)
} else {
as.data.frame(input, stringsAsFactors = FALSE)
}
# Check that all necessary input variables are present
nms <- names(nd)
stopifnot("zip" %in% nms)
stopifnot("na" %in% nms)
stopifnot("nc" %in% nms)
stopifnot("hinc" %in% nms)
stopifnot("hfuel" %in% nms)
stopifnot("veh" %in% nms)
stopifnot("htype" %in% nms)
# Detect if the input is a test dataset
# If the original training data is submitted, all 'zip' values will be NA
test <- all(is.na(nd$zip))
#-----
nd$id <- 1:nrow(nd)
# Assign geographic variables to 'nd' using zip code provided
# If statement used to allow testing with the original dataset (which contains spatial variables but not zip code)
if (!test) {
nd <- merge(nd, zip_lookup, sort = FALSE)
}
# Assign price adjustment factors based on assigned state
# If statement used to allow testing with the original dataset (no price adjustments necessary)
if (!test) {
nd <- merge(nd, price_adjustment, sort = FALSE)
} else {
temp <- price_adjustment
temp[,-1] <- 1
nd <- merge(nd, temp, sort = FALSE)
}
# Ensure that original order to maintained; probably not necessry is sort = FALSE in merge()
nd <- nd[order(nd$id),]
# Estimate household marginal tax rate
# This is based on 2017 rates and brackets using household income as reported as user
nd$mrate <- margRate(nd)
# Adult pre-tax dividend amount
# Hard-coded; based on original CCL analysis for 2008-2012 period
# NOTE: This is NOT adjusted for inflation
# Total revenue in analysis assumes $15 per ton at 2012 emission levels; $377 is based on those assumptions
div.adult <- 377
# Calculate pre-tax dividend amount, adjusted to current dollars
if (!test) {
nd$div_pre <- round(div.adult * nd$na + 0.5 * div.adult * pmin(2, nd$nc))
} else {
# The "nc - 1" is necessary to account for fact that test dataset added 1 to both 'nc' and 'veh' to avoid errors with log() in model formulas
# Rounding necessary to account for jitter added to test dataset numeric variables
nd$div_pre <- round(div.adult * round(nd$na) + 0.5 * div.adult * pmin(2, round(nd$nc - 1)))
}
# Fuel-price-to-income ratios used in model fitting
# Note that fuel prices are adjusted from 2012 to current price levels
# If statement will skip this is using test dataset (elec_ratio and gas_ratio already in the data frame)
if (!test) {
nd$elec_ratio <- nd$cents_kwh * nd$elec_adjust / (nd$hinc / 1e3)
nd$gas_ratio <- nd$gasprice * nd$gas_adjust / (nd$hinc / 1e3)
}
# Deflate user input household income to 2012 levels using CPI
# This ensures that income matches currency units of original data and models
nd$hinc <- nd$hinc / nd$cpi_adjust
# Add 1 to 'nc' and 'veh' to allow log() calls in model prediction
# Not necessary when test dataset is being used
if (!test) {
nd$nc <- nd$nc + 1
nd$veh <- nd$veh + 1
}
# Total number of people in household
# Necessary to subtract 1 to account for addition to 'nc' immediately above
nd$np <- nd$na + nd$nc - 1
#----------------------
# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
other.id <- which(nd$hfuel == "Other or none")
if (length(other.id) > 0) {
nd$hfuel[other.id] <- "Natural gas"
}
# If user does not know heating fuel, make a guess
# Fitted GLM model returns probability of Natural gas; Electricity otherwise (only two options)
donotknow.id <- which(nd$hfuel == "Do not know")
if (length(donotknow.id) > 0) {
pred <- stats::predict.glm(hfuel_model, newdata = nd[donotknow.id,])
# Convert from original scale to class probability (probability of Natural gas)
# https://stats.stackexchange.com/questions/164648/output-of-logistic-regression-prediction
prob <- exp(pred) / (1 + exp(pred))
nd$hfuel[donotknow.id] <- ifelse(prob >= 0.5, "Natural gas", "Electricity")
}
# Estimate core emissions and associated standard deviation, assuming Normal distribution
# Note exp() used to convert log prediction value
core <- as.numeric(exp(mgcv::predict.gam(core_model_gam, newdata = nd)))
q <- exp(quantreg::predict.rq(core_model_rq, newdata = nd))
if (nrow(nd) == 1) {
stdev <- (q[2] - q[1]) / 1.35
} else {
stdev <- (q[,2] - q[,1]) / 1.35
}
#----------------------
# Predict typical (mean) and upper-bound (approximately 97.5th percentile) expenditure values used to set the "page 2" slider preset and maximum value
# Note that all dollar values are adjusted to reflect current price levels ("_adjust" variables)
# Gasoline monthly expenditure (mean and approximately 97.5th percentile)
gas <- cbind(mgcv::predict.gam(gas_model_gam, newdata = nd), 1.1 * quantreg::predict.rq(gas_model_rq, newdata = nd))
gas <- signif(gas * nd$gas_adjust * nd$gasprice / 12, digits = 2)
#gas <- signif(predict(gas_model, newdata = nd) * nd$gas_adjust * nd$gasprice / 52, digits = 2)
colnames(gas) <- c("gas", "gas_upr")
gas[which(nd$veh == 1), "gas"] <- 0  # Set predicted gasoline expenditure to zero if user inputs zero vehicles (which is actually "1" in nd$veh after +1 to original value (above)
# Electricity monthly expenditure (mean and approximately 97.5th percentile)
elec <- cbind(mgcv::predict.gam(elec_model_gam, newdata = nd), 1.1 * quantreg::predict.rq(elec_model_rq, newdata = nd))
elec <- signif(elec * nd$elec_adjust * nd$cents_kwh / 12, digits = 2)
#elec <- signif(predict(elec_model, newdata = nd) * nd$elec_adjust * nd$cents_kwh / 12, digits = 2)
colnames(elec) <- c("elec", "elec_upr")
# Primary heating fuel monthly expenditure (median and approximately 95th percentile)
# Note that expenditure values are adjusted to current price levels AND
#  CIE values are adjusted to reflect change in fuel prices since 2012 (if price went up, CIE goes down)
predHeatModels <- function(d) {
if (d$hfuel[1] == "Natural gas") {
if (!test) d$heat_ratio <- d$ngasprice * d$ngas_adjust / (d$hinc / 1e3)
out <- cbind(mgcv::predict.gam(ngas_model_gam, newdata = d), 1.1 * quantreg::predict.rq(ngas_model_rq, newdata = d)) * ifelse(!test, d$ngasprice, d$heatprice) * d$ngas_adjust
out <- cbind(out, d$Natural_gas_cie / d$ngas_adjust)
}
if (d$hfuel[1] == "LPG/Propane") {
if (!test) d$heat_ratio <- d$lpgprice * d$lpg_adjust / (d$hinc / 1e3)
out <- cbind(mgcv::predict.gam(lpg_model_gam, newdata = d), 1.1 * quantreg::predict.rq(lpg_model_rq, newdata = d)) * ifelse(!test, d$lpgprice, d$heatprice) * d$lpg_adjust
out <- cbind(out, d$LPG_cie / d$lpg_adjust)
}
if (d$hfuel[1] == "Heating oil") {
if (!test) d$heat_ratio <- d$hoilprice * d$hoil_adjust / (d$hinc / 1e3)
out <- cbind(mgcv::predict.gam(hoil_model_gam, newdata = d), 1.1 * quantreg::predict.rq(hoil_model_rq, newdata = d)) * ifelse(!test, d$hoilprice, d$heatprice) * d$hoil_adjust
out <- cbind(out, d$Heating_oil_cie / d$hoil_adjust)
}
# If heating fuel is Electricity, return zeros
if (d$hfuel[1] %in% c("Electricity")) {
out <- matrix(rep(0, 3 * nrow(d)), ncol = 3)
}
out <- cbind(d$id, out)
colnames(out) <- c("id", "heat", "heat_upr", "heat_cie")
out[,c("heat", "heat_upr")] <- signif(out[,c("heat", "heat_upr")] / 12, 2)
return(out)
}
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- as.data.frame(do.call("rbind", heat))
heat <- heat[order(heat$id), -1]
#----------------------
# Carbon price ($ per ton CO2; fixed)
carbon.price <- 15
# Estimated 90% margin of error (in dollars, annual)
# Since emissions/tax burden from fuel use is assumed to be accurate (based on user specified values),
#  the overall MOE is the modeled uncertainty in the "core" emissions
nd$moe <- round(1.645 * stdev * carbon.price)
# Annual cost equation
nd$cost <- paste(
round(core * carbon.price, 2),
paste0("gas * ", signif(12 * nd$Gasoline_cie / nd$gas_adjust * (carbon.price / 1e3), 4)),  # Input is monthly expenditure
paste0("elec * ", signif(12 * nd$Electricity_cie / nd$elec_adjust * (carbon.price / 1e3), 4)),  # Input is monthly expenditure
paste0("heat * ", signif(12 * heat$heat_cie * (carbon.price / 1e3), 4)),
sep = " + ")  # Input is monthly expenditure
# For users that did not know their heating fuel, replace the 'heat' component
#  of cost equation with the default expenditure value and set 'heat' and 'heat_upr' variables to zero
if (length(donotknow.id) > 0) {
for (i in donotknow.id) nd$cost[i] <- sub("heat", heat$heat[i], nd$cost[i], fixed = TRUE)
heat$heat[donotknow.id] <- 0
heat$heat_upr[donotknow.id] <- 0
}
# For users that report heating fuel as "Other or none", replace the 'heat' component
#  of cost equation with ZERO value and set heat-related presets to zero
if (length(other.id) > 0) {
for (i in other.id) nd$cost[i] <- sub("heat", 0, nd$cost[i], fixed = TRUE)
}
heat[other.id,] <- 0
# Return results matrix
psets <- cbind(gas, elec, heat)
psets[psets < 0] <- 0
result <- cbind(nd, psets)
result <- subset(result, select = c(div_pre, mrate, cost, moe, gas, elec, heat, gas_upr, elec_upr, heat_upr))
return(result)
}
input <- data.frame(zip = c("94062","80524","99501"), na = c(2, 1, 3), nc = c(2, 0, 3), hinc = c(50e3, 300e3, 100e3), hfuel = c("Do not know", "Natural gas", "Other or none"), veh = c(2, 0, 3), htype = c("Stand-alone house", "Apartment building", "Other"), stringsAsFactors = FALSE)
for (i in list.files("data/", full.names = TRUE)) load(i)
test <- predictModel(input)
test
