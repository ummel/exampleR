# Core emissions
# Calculate 90% CI margin of error (MOE) This is calculated by estimating the
# standard deviation, assuming a Normal distribution with specified 25th and
# 75th percentiles (the IQR is approximately 1.35x the standard deviation)
# There were no 'Other or none' observations in the trimmed training dataset,
# so this replacement assures the core_model predict() function will not fail
# 'nd' object retains 'Other or none' so that hfuel logic further down still works
other.id <- which(nd$hfuel == "Other or none")
if (length(other.id) > 0) {
nd$hfuel[other.id] <- "Natural gas"
}
# If user does not know heating fuel, make a guess
# Fitted GLM model returns probability of Natural gas; Electricity otherwise (only two options)
donotknow.id <- which(nd$hfuel == "Do not know")
if (length(donotknow.id) > 0) {
pred <- stats::predict.glm(hfuel_model, newdata = nd[donotknow.id,])
# Convert from original scale to class probability (probability of Natural gas)
# https://stats.stackexchange.com/questions/164648/output-of-logistic-regression-prediction
prob <- exp(pred) / (1 + exp(pred))
nd$hfuel[donotknow.id] <- ifelse(prob >= 0.5, "Natural gas", "Electricity")
}
# Note exp() used to convert log prediction value
core <- as.numeric(exp(mgcv::predict.gam(core_model_gam, newdata = nd)))
q <- exp(quantreg::predict.rq(core_model_rq, newdata = nd))
if (nrow(nd) == 1) {
stdev <- (q[2] - q[1]) / 1.35
} else {
stdev <- (q[,2] - q[,1]) / 1.35
}
#----------------------
# Predict typical (mean) and upper-bound (approximately 97.5th percentile) expenditure values used to set the "page 2" slider preset and maximum value
# Note that all dollar values are adjusted to reflect current price levels ("_adjust" variables)
# Gasoline monthly expenditure (mean and approximately 97.5th percentile)
gas <- cbind(mgcv::predict.gam(gas_model_gam, newdata = nd), 1.1 * quantreg::predict.rq(gas_model_rq, newdata = nd))
gas <- signif(gas * nd$gas_adjust * nd$gasprice / 12, digits = 2)
#gas <- signif(predict(gas_model, newdata = nd) * nd$gas_adjust * nd$gasprice / 52, digits = 2)
colnames(gas) <- c("gas", "gas_upr")
gas[which(nd$veh == 1), "gas"] <- 0  # Set predicted gasoline expenditure to zero if user inputs zero vehicles (which is actually "1" in nd$veh after +1 to original value (above)
# Electricity monthly expenditure (mean and approximately 97.5th percentile)
elec <- cbind(mgcv::predict.gam(elec_model_gam, newdata = nd), 1.1 * quantreg::predict.rq(elec_model_rq, newdata = nd))
elec <- signif(elec * nd$elec_adjust * nd$cents_kwh / 12, digits = 2)
#elec <- signif(predict(elec_model, newdata = nd) * nd$elec_adjust * nd$cents_kwh / 12, digits = 2)
colnames(elec) <- c("elec", "elec_upr")
# Primary heating fuel monthly expenditure (median and approximately 95th percentile)
# Note that expenditure values are adjusted to current price levels AND
#  CIE values are adjusted to reflect change in fuel prices since 2012 (if price went up, CIE goes down)
predHeatModels <- function(d) {
if (d$hfuel[1] == "Natural gas") {
if (!test) d$heat_ratio <- d$ngasprice * d$ngas_adjust / (d$hinc / 1e3)
out <- cbind(mgcv::predict.gam(ngas_model_gam, newdata = d), 1.1 * quantreg::predict.rq(ngas_model_rq, newdata = d)) * ifelse(!test, d$ngasprice, d$heatprice) * d$ngas_adjust
out <- cbind(out, d$Natural_gas_cie / d$ngas_adjust)
}
if (d$hfuel[1] == "LPG/Propane") {
if (!test) d$heat_ratio <- d$lpgprice * d$lpg_adjust / (d$hinc / 1e3)
out <- cbind(mgcv::predict.gam(lpg_model_gam, newdata = d), 1.1 * quantreg::predict.rq(lpg_model_rq, newdata = d)) * ifelse(!test, d$lpgprice, d$heatprice) * d$lpg_adjust
out <- cbind(out, d$LPG_cie / d$lpg_adjust)
}
if (d$hfuel[1] == "Heating oil") {
if (!test) d$heat_ratio <- d$hoilprice * d$hoil_adjust / (d$hinc / 1e3)
out <- cbind(mgcv::predict.gam(hoil_model_gam, newdata = d), 1.1 * quantreg::predict.rq(hoil_model_rq, newdata = d)) * ifelse(!test, d$hoilprice, d$heatprice) * d$hoil_adjust
out <- cbind(out, d$Heating_oil_cie / d$hoil_adjust)
}
# If heating fuel is Electricity, return zeros
if (d$hfuel[1] %in% c("Electricity")) {
out <- matrix(rep(0, 3 * nrow(d)), ncol = 3)
}
out <- cbind(d$id, out)
colnames(out) <- c("id", "heat", "heat_upr", "heat_cie")
out[,c("heat", "heat_upr")] <- signif(out[,c("heat", "heat_upr")] / 12, 2)
return(out)
}
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- data.frame(do.call("rbind", heat))
heat <- heat[order(heat$id), -1]
?data.frame
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- data.frame(do.call("rbind", heat), row.names = "id")
heat <- heat[order(heat$id), -1]
dim(Heat)
dim(heat)
head(heat)
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- data.frame(do.call("rbind", heat), row.names = FALSE)
heat <- by(nd, nd$hfuel, predHeatModels)
temp <- do.call("rbind", heat)
head(temp)
class(temp)
temp = as.data.frame(temp)
head(temp)
heat <- by(nd, nd$hfuel, predHeatModels)
heat <- as.data.frame(do.call("rbind", heat))
heat <- heat[order(heat$id), -1]
head(heat)
source("R/predict model.R")
test <- predictModel(head(dset, 1000))
dim(test)
head(test)
test <- predictModel(dset)
?sample-frace
library(tidyverse)
test <- predictModel(sample_frac(dset, 0.05))
nrow(dset)*0.05
dim(test)
head(test)
samp <- sample_frac(dset, 0.05)
test <- predictModel(samp)
# Mean predicted electricity expenditure (2012 prices)
weighted.mean(test$elec, samp$hw)
131*12
# Mean predicted (median) monthly electricity expenditure (2012 prices)
weighted.mean(test$gas, samp$hw)
362*12
weighted.mean(samp$Electricity * samp$elecprice, samp$hw)
# Mean predicted (median) monthly electricity expenditure (2012 prices)
weighted.mean(test$gas, samp$hw) * 12
# Mean predicted (median) monthly electricity expenditure (2012 prices)
weighted.mean(test$elec, samp$hw) * 12
weighted.mean(samp$Electricity * samp$elecprice, samp$hw)
head(test)
weighted.mean(samp$core, samp$hw)
x <- strsplit(test$cost, " + ", fixed = TRUE)
x[[1]]
x <- sapply(strsplit(test$cost, " + ", fixed = TRUE), function(x) as.numeric(x[1]) / 15
x <- sapply(strsplit(test$cost, " + ", fixed = TRUE), function(x) as.numeric(x[1]) / 15)
head(x)
weighted.mean(samp$core, samp$hw)
x <- sapply(strsplit(test$cost, " + ", fixed = TRUE), function(x) as.numeric(x[1]) / 15)
weighted.mean(x, samp$hw)
samp <- sample_frac(dset, 0.1)
test <- predictModel(samp)
names(samp)
head(test)
# Compare mean 'core' emissions in original sample to the implied amount returned by predictModel()
weighted.mean(samp$core, samp$hw)
dim(samp)
weighted.mean(sapply(strsplit(test$cost, " + ", fixed = TRUE), function(x) as.numeric(x[1]) / 15), samp$hw)
names(samp)
# Compare mean pre-tax divided emissions in original sample to the implied amount returned by predictModel()
weighted.mean(test$div_pre, samp$hw)
names(nd)
names(samp)
hist(samp$na)
head(samp$na)
samp$div_pre <- round(div.adult * round(nd$na) + 0.5 * div.adult * pmin(2, round(nd$nc)))
# Compare mean pre-tax divided emissions in original sample to the implied amount returned by predictModel()
div.adult <- 377
samp$div_pre <- round(div.adult * round(nd$na) + 0.5 * div.adult * pmin(2, round(nd$nc)))
samp$div_pre <- round(div.adult * round(samp$na) + 0.5 * div.adult * pmin(2, round(samp$nc)))
head(samp)
pmin(2,2)
unique(round(samp$nc))
div.adult <- 377
samp$div_pre <- round(div.adult * round(samp$na) + 0.5 * div.adult * pmin(2, round(samp$nc - 1)))
weighted.mean(samp$div_pre, sampe$hw)
weighted.mean(samp$div_pre, samp$hw)
weighted.mean(test$div_pre, samp$hw)
dim(temp)
dim(samp)
dim(test)
head(test$div_pre)
head(samp$div_pre)
samp1,
samp[1,]
source("R/predict model.R")
samp <- sample_frac(dset, 0.1)
test <- predictModel(samp)
# Compare mean pre-tax divided emissions in original sample to the implied amount returned by predictModel()
# The "nc - 1" is necessary to account for fact that model dataset added 1 to both 'nc' and 'veh' to avoid errors with log() in model formulas
div.adult <- 377
samp$div_pre <- round(div.adult * round(samp$na) + 0.5 * div.adult * pmin(2, round(samp$nc - 1)))
all(samp$div_pre == test$div_pre)
head(samp$div_pre)
head(test$div_pre)
source("R/predict model.R")
samp <- sample_frac(dset, 0.001)
test <- predictModel(samp)
head(samp$div_pre)
div.adult <- 377
samp$div_pre <- round(div.adult * round(samp$na) + 0.5 * div.adult * pmin(2, round(samp$nc - 1)))
all(samp$div_pre == test$div_pre)
samp$div_pre
head(samp$div_pre)
head(test$div_pre)
# Compare mean pre-tax dividend implied by original data and that returned by predictModel()
# Note: These values should match EXACTLY...
# The "nc - 1" is necessary to account for fact that model dataset added 1 to both 'nc' and 'veh' to avoid errors with log() in model formulas
div.adult <- 377
samp$div_pre <- round(div.adult * round(samp$na) + 0.5 * div.adult * pmin(2, round(samp$nc - 1)))
all(samp$div_pre == test$div_pre)
dim(test)
weighted.mean(samp$div_pre, samp$hw)
weighted.mean(test$div_pre, samp$hw)
# Compare mean 'core' emissions in original sample to the implied amount returned by predictModel()
weighted.mean(samp$core, samp$hw)
weighted.mean(sapply(strsplit(test$cost, " + ", fixed = TRUE), function(x) as.numeric(x[1]) / 15), samp$hw)
head(test)
weighted.mean(test$div_pre, samp$hw)
# Compute predicted carbon footprint for each household in 'test'
x <- strsplit(test$cost, " + ", fixed = TRUE)
x[[1]]
# Compute predicted carbon footprint for each household in 'test'
x <- as.matrix(strsplit(test$cost, " + ", fixed = TRUE))
dim(x)
?do.call
# Compute predicted carbon footprint for each household in 'test'
x <- do.call(rbind, strsplit(test$cost, " + ", fixed = TRUE))
head(x)
dim(x)
class(x)
head(x)
check <- gsub("gas", "s", test$cost)
head(check)
check <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
head(check)
check <- sprintf(check, test$gas, test$elec, test$heat)
heaD(check)
head(check)
head(test)
check <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
head(checl)
head(checl)
head(check)
head(test$cost)
check2 <- sprintf(check, test$gas, test$elec, test$heat)
head(check2)
head(test)
check2[1]
test[1,]
check2[2]
test[2,]
check <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
check <- sprintf(check, test$gas, test$elec, test$heat)
check[2]
test.tco2 <- eval(check)
test.tco2
class(test.tco2)
length(test.tco2)
?eval
test.tco2 <- sapply(check, eval)
head(test.tco2)
head(eval(parse(text = check)))
temp <- eval(parse(text = check))
length(temp)
temp
temp <-
test.tco2 <- sapply(check, function(x) eval(parse(text = x)))
head(test.tco2)
test.tco2 <- as.numeric(sapply(check, function(x) eval(parse(text = x))))
head(test.tco2)
test.tco2 <- as.numeric(sapply(check, function(x) eval(parse(text = x)))) / 15
head(test.tco2)
summary(test.tco2)
weighted.mean(test.tco2, samp$hw)
cost <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
cost <- sprintf(check, test$gas, test$elec, test$heat)
head(cost)
rm(check)
test.tco2 <- as.numeric(sapply(cost, function(x) eval(parse(text = x)))) / 15
weighted.mean(test.tco2, samp$hw)
head(samp)
summary(samp$mtco2)
head(test.tco2)
cost <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
cost <- sprintf(check, test$gas, test$elec, test$heat)
test.tco2 <- as.numeric(sapply(cost, function(x) eval(parse(text = x)))) / 15
weighted.mean(test.tco2, samp$hw)
weighted.mean(samp$mtco2, samp$hw)
samp <- sample_frac(dset, 0.10)
test <- predictModel(samp)
div.adult <- 377
samp$div_pre <- round(div.adult * round(samp$na) + 0.5 * div.adult * pmin(2, round(samp$nc - 1)))
all(samp$div_pre == test$div_pre)
cost <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
cost <- sprintf(check, test$gas, test$elec, test$heat)
test.tco2 <- as.numeric(sapply(cost, function(x) eval(parse(text = x)))) / 15  # Total given by cost formula divided by $15/ton carbon price
dim(samp)
dim(test)
cost <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
cost <- sprintf(cost, test$gas, test$elec, test$heat)
test.tco2 <- as.numeric(sapply(cost, function(x) eval(parse(text = x)))) / 15  # Total given by cost formula divided by $15/ton carbon price
weighted.mean(test.tco2, samp$hw)
weighted.mean(samp$mtco2, samp$hw)
plot(samp$mtco2, test.tco2)
names(samp)
# Overall R-squared value between original and predictModel() output, using the original fuel expenditures (i.e. assuming users report fuel expenditure accurately)
cost2 <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
cost2 <- sprintf(cost, samp$Gasoline * samp$gasprice / 12, samp$Electricity * samp$elecprice / 12, samp$Heating * samp$heatprice / 12)
# Overall R-squared value between original and predictModel() output, using the original fuel expenditures (i.e. assuming users report fuel expenditure accurately)
cost2 <- gsub("heat", "%d", gsub("elec", "%d", gsub("gas", "%d", test$cost)))
cost2 <- sprintf(cost2, samp$Gasoline * samp$gasprice / 12, samp$Electricity * samp$elecprice / 12, samp$Heating * samp$heatprice / 12)
# Overall R-squared value between original and predictModel() output, using the original fuel expenditures (i.e. assuming users report fuel expenditure accurately)
cost2 <- gsub("heat", "%f", gsub("elec", "%f", gsub("gas", "%f", test$cost)))
cost2 <- sprintf(cost2, samp$Gasoline * samp$gasprice / 12, samp$Electricity * samp$elecprice / 12, samp$Heating * samp$heatprice / 12)
head(cost2)
pred.tco2 <- as.numeric(sapply(cost2, function(x) eval(parse(text = x)))) / 15  # Total given by cost formula divided by $15/ton carbon price
head(pred.tco2)
weighted.mean(pred.tco2, samp$hw)
weighted.mean(test.tco2, samp$hw)
cor(pred.tco2, samp$mtco2) ^ 2
cor(test.tco2, samp$mtco2) ^ 2
cost2 <- gsub("heat", "%f", gsub("elec", "%f", gsub("gas", "%f", test$cost)))
cost2 <- sprintf(cost2, samp$Gasoline * samp$gasprice / 12, samp$Electricity * samp$elecprice / 12, samp$Heating * samp$heatprice / 12)
best.tco2 <- as.numeric(sapply(cost2, function(x) eval(parse(text = x)))) / 15  # Total given by cost formula divided by $15/ton carbon price
cor(best.tco2, samp$mtco2) ^ 2
# R-squared between original sample household footprint and the value returned by predictModel() - including use of default gasoline and utility expenditures
cor(test.tco2, samp$mtco2) ^ 2
roxygen2::roxygenize()
?predictModel
build()
library(exampleR)
?predictModel
devtools::build()
library(exampleR)
?predictModel
devtools::build()
library(exampleR)
?predictModel
library(exampleR)
?predictModel
roxygen2::roxygenize()
devtools::build()
detach(exampler)
detach(exampleR)
detach("exampleR")
library(exampleR)
?predictModel
devtools:build()
devtools::build()
?predictModel
library(exampleR)
?predictModel
library(devtools)
?build
build(manual = TRUE)
library(exaampler)
library(exampleR)
?predictModel
library(exampleR)
?predictModel
document()
library(devtools)
document()
?predictModel
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
require(quantreg, quietly = TRUE);require(mgcv, quietly = TRUE)
source("R/marginal rate.R")
for (i in list.files("data/", full.names = TRUE)) load(i)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = 2, htype = "Other", stringsAsFactors = FALSE)
predictModel(nd)
document()
?predict.smooth.spline
?predictModel
document()
predictModel(nd)
?predictModel
?margRate
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
document()
?predictModel
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = 2, htype = "Other", stringsAsFactors = FALSE)
predictModel(nd)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = 2, htype = "Other")
predictModel(nd)
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
?predictModel
document()
document()
?predictModel
roxygen2::roxygenise()
nd <- data.frame(zip = "80524", na = 2, nc = 2, hinc = 204e3, hfuel = "Do not know", veh = 2, htype = "Other", stringsAsFactors = FALSE)
predictModel(nd)
1131*(1-0.28)
1131*(1-0.28)/12
665.98 + 310 * 0.764 + 130 * 1.287 + 56 * 1.024
1127.474/12
665.98 + 310 * 0.764 + 130 * 1.287 + 56 * 1.024
1127.474/12
665.98 + 310 * 0.764 + 130 * 1.287 + 0 * 1.024
1070.13/12
377*.75/12
264.51 + 210 * 0.764 + 64 * 1.287 + 51 * 1.024
(264.51 + 210 * 0.764 + 64 * 1.287 + 51 * 1.024)/12
380.37 + 260 * 0.764 + 95 * 1.287 + 53 * 1.024
755.547/12
380.37 + 480 * 0.764 + 220 * 1.287 + 53 * 1.024
1084/12
head(price_adjustment)
2083/12
2756/3194
summary(price_adjustment)
document()
?predictMOdel
?predictModel
roxygen2::roxygenize()
document()
?predictModel
Rd2HTML
?Rd2HTML
library(toosl)
library(tools)
Rd2HTML
# for (i in list.files("data/", full.names = TRUE)) load(i)
#
# nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = 2, htype = "Other", stringsAsFactors = FALSE)
# nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Other or none", veh = 2, htype = "Stand-alone house", stringsAsFactors = FALSE)
# nd <- data.frame(zip = c("94062","80524","70032"), na = c(2, 1, 3), nc = c(2, 0, 3), hinc = c(50e3, 300e3, 100e3), hfuel = c("Do not know", "Natural gas", "Other or none"), veh = c(2, 0, 3), htype = c("Stand-alone house", "Apartment building", "Other"), stringsAsFactors = FALSE)
#
# predictModel(nd)
#
# To convert ?predictModel documentation to stand-alone HTML
#library(tools)
Rd2HTML("man/predictModel.Rd", "Documentation.html")
