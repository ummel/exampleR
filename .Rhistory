mutate(state = factor(state)) %>%
inner_join(spend) %>%
filter(income > 0, income < quantile(income, 0.95), electricity < quantile(electricity, 0.95)) %>%  # Restrict income and electricity expenditure within reasonable bounds
select(hw, state, hhsize, minors, age, income, electricity, gasoline, cost_co2) %>%
sample_frac(0.05)
dset <- d %>%
filter(year == 2012) %>%
rename(state = state.name, hhsize = np, minors = nc, income = hinc) %>%
mutate(state = factor(state)) %>%
inner_join(spend)
head(dset)
head(spend)
summary(spend)
spend <- read_rds("~/Documents/Projects/CCL/Data/Results/Household category expenditure and emissions 2012.rds") %>%
filter(cat %in% c("Utilities", "Gasoline"), year == 2012, expend > 0) %>%
select(id, cat, expend) %>%
spread(cat, expend) %>%
rename(gas = Gasoline, elec = Utilities)
head(spend)
summary(spend)
# Household level spending
spend <- read_rds("~/Documents/Projects/CCL/Data/Results/Household category expenditure and emissions 2012.rds") %>%
filter(cat %in% c("Utilities", "Gasoline"), year == 2012, expend > 0) %>%
select(id, cat, expend) %>%
spread(cat, expend, fill = 0) %>%
rename(gas = Gasoline, elec = Utilities) %>%   # Temporary: Using total utilities expenditure at household level to proxy for monthly electricity expenditure
mutate(elec = elec * 1400 / mean(electricity),
elec = elec / 12,  # Monthly electricity expenditure; set the mean to $1400 per year
gas = gas / 52) # Weekly average gasoline expenditure
# Household level spending
spend <- read_rds("~/Documents/Projects/CCL/Data/Results/Household category expenditure and emissions 2012.rds") %>%
filter(cat %in% c("Utilities", "Gasoline"), year == 2012, expend > 0) %>%
select(id, cat, expend) %>%
spread(cat, expend, fill = 0) %>%
rename(gas = Gasoline, elec = Utilities) %>%   # Temporary: Using total utilities expenditure at household level to proxy for monthly electricity expenditure
mutate(elec = elec * 1400 / mean(elec),
elec = elec / 12,  # Monthly electricity expenditure; set the mean to $1400 per year
gas = gas / 52) # Weekly average gasoline expenditure
dset <- d %>%
filter(year == 2012) %>%
rename(state = state.name, hhsize = np, minors = nc, income = hinc) %>%
mutate(state = factor(state)) %>%
inner_join(spend) %>%
filter(income > 0, income < quantile(income, 0.95), elec < quantile(elec, 0.95)) %>%  # Restrict income and electricity expenditure within reasonable bounds
select(hw, state, hhsize, minors, age, income, elec, gas, cost_co2) %>%
sample_frac(0.05)
dim(dset)
head(dset)
summary(dset)
# Create vector of predictor variables
pred <- setdiff(names(dset), c("hw", "cost_co2"))
pred
# Vector giving the var.monotone integer (-1, 0, 1) for each predictor variable
# Zero (no relationship) is the default
mono <- rep(0, length(pred))
mono[which(pred %in% c("elec", "gas"))] <- 1
# Fit GBM model #0
# This model uses the full set of predictors
fitted_model0 <- gbm(formula = formula(paste0("cost_co2 ~ ", paste(pred, collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model0, file = "data/fitted_model0.rda")
#----------
# Fit GBM model #1 - income
# This model uses ONLY the non-slider predictors  (slider predictors are assumed to be those where 'mono' == 1)
fitted_model1 <- gbm(formula = formula(paste0("elec ~ ", paste(pred[mono != 1], collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
#var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model1, file = "data/fitted_model1.rda")
# Fit GBM model #2 - elec
# This model uses ONLY the non-slider predictors (slider predictors are assumed to be those where 'mono' == 1)
fitted_model2 <- gbm(formula = formula(paste0("gas ~ ", paste(pred[mono != 1], collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
#var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model2, file = "data/fitted_model2.rda")
summary(nd)
round(377 * 2 + 0.5 * div.adult * 1
)
round(377 * 2 + 0.5 * 377 * 1
)
library(exampleR)
data("fitted_model0")
data("fitted_model1")
data("fitted_model2")
data("zip_lookupp")
data("zip_lookup")
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3)
nd
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
library(gbm)
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
nd
names(nd)
fitted_model2$response.name
fitted_model1$response.name
library(gbm)
library(tidyverse)
d <- read_rds("~/Documents/Projects/CCL/Data/Results/Policy simulation results by household.rds")
# Household level spending
spend <- read_rds("~/Documents/Projects/CCL/Data/Results/Household category expenditure and emissions 2012.rds") %>%
filter(cat %in% c("Utilities", "Gasoline"), year == 2012, expend > 0) %>%
select(id, cat, expend) %>%
spread(cat, expend, fill = 0) %>%
rename(gas = Gasoline, elec = Utilities) %>%   # Temporary: Using total utilities expenditure at household level to proxy for monthly electricity expenditure
mutate(elec = elec * 1400 / mean(elec),
elec = elec / 12,  # Monthly electricity expenditure; set the mean to $1400 per year
gas = gas / 52) # Weekly average gasoline expenditure
# Adult pre-tax dividend amount
filter(d, np == 1, nc == 0)$div_pre[1]
# Fit GBM model predicting cost_co2, based on following user inputs:
# State of residence
# Household size
# Number of minors
# Age of householder
# Household income
# Monthly electricity expenditure (slider variable)
# Weekly gasoline expenditure (slider variable)
dset <- d %>%
filter(year == 2012) %>%
rename(state = state.name, hhsize = np, minors = nc, income = hinc) %>%
mutate(state = factor(state)) %>%
inner_join(spend) %>%
filter(income > 0, income < quantile(income, 0.95), elec < quantile(elec, 0.99), gas < quantile(gas, 0.99)) %>%  # Restrict income and electricity expenditure within reasonable bounds
select(hw, state, hhsize, minors, age, income, elec, gas, cost_co2) %>%
sample_frac(0.05)
# Create vector of predictor variables
pred <- setdiff(names(dset), c("hw", "cost_co2"))
# Vector giving the var.monotone integer (-1, 0, 1) for each predictor variable
# Zero (no relationship) is the default
mono <- rep(0, length(pred))
mono[which(pred %in% c("elec", "gas"))] <- 1
#----------
# Fit GBM model #0
# This model uses the full set of predictors
fitted_model0 <- gbm(formula = formula(paste0("cost_co2 ~ ", paste(pred, collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model0, file = "data/fitted_model0.rda")
#----------
# Fit GBM model #1 - income
# This model uses ONLY the non-slider predictors  (slider predictors are assumed to be those where 'mono' == 1)
fitted_model1 <- gbm(formula = formula(paste0("elec ~ ", paste(pred[mono != 1], collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
#var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model1, file = "data/fitted_model1.rda")
# Fit GBM model #2 - elec
# This model uses ONLY the non-slider predictors (slider predictors are assumed to be those where 'mono' == 1)
fitted_model2 <- gbm(formula = formula(paste0("gas ~ ", paste(pred[mono != 1], collapse = "+"))),
distribution = "gaussian",
data = dset,
weights = dset$hw,
#var.monotone = mono,
n.trees = 1500,
interaction.depth = length(pred),
keep.data = FALSE)
# Save model object to disk as .rda object
save(fitted_model2, file = "data/fitted_model2.rda")
fitted_model2$response.name
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#------
# Predict the slider preset values
#for (x in ls(pattern = "fitted_model")[-1]) {
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
nd
73*52
plot.gbm
fitted_model0$var.levels
m <- fitted_model0
v <- c("elec", "gas")
v
m$var.names
match(v, m$var.names)
m$var.levels
m$var.levels[[i]]
test <- sapply(i, function(x) {m$var.levels[[i]]})
i <- match(v, m$var.names)
test <- sapply(i, function(x) {m$var.levels[[i]]})
test
test <- sapply(i, function(x) {range(m$var.levels[[i]])})
tet
test
i
test <- sapply(i, function(x) {range(m$var.levels[[x]])})
test
test <- lapply(i, function(x) {range(m$var.levels[[x]])})
test
summary(dset)
test
?seq
test <- lapply(i, function(x)       seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = res))
res = 100
test <- lapply(i, function(x)       seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = res))
test
names(test) <- v
test
temp <- expand.grid(test)
head(temp)
dim(temp)
head(temp)
temp <- cbind(nd, expand.grid(test))
dim(temp)
head(temp)
pred <- cbind(nd, expand.grid(test))
v <- c("elec", "gas")
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
pred <- cbind(nd, expand.grid(test))
pred$y <- predict.gbm(fitted_model0, newdata = pred, n.trees = fitted_model0$n.trees)
dim(pred)
v <- c("elec", "gas")
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
pred <- cbind(nd, expand.grid(g))
pred$y <- predict.gbm(fitted_model0, newdata = pred, n.trees = fitted_model0$n.trees)
head(pred)
dim(pred)
summary(pred)
pred
v <- c("elec", "gas")
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
x <- cbind(nd, expand.grid(g))
x$y <- predict.gbm(fitted_model0, newdata = x, n.trees = fitted_model0$n.trees)
head(x)
predict.gbm(fitted_model0, newdata = nd, n.trees = fitted_model0$n.trees)
nd
predict.gbm(fitted_model0, newdata = data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 70e3, n.trees = fitted_model0$n.trees)
)
predict.gbm(fitted_model0, newdata = data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 70e3), n.trees = fitted_model0$n.trees)
predict.gbm(fitted_model0, newdata = data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 70e3), n.trees = fitted_model0$n.trees)
predict.gbm(fitted_model0, newdata = data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 70e3, elec = 100, gas = 75), n.trees = fitted_model0$n.trees)
predict.gbm(fitted_model0, newdata = data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 70e3, elec = 100, gas = 85), n.trees = fitted_model0$n.trees)
predict.gbm(fitted_model0, newdata = data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 70e3, elec = 100, gas = 105), n.trees = fitted_model0$n.trees)
predict.gbm(fitted_model0, newdata = data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 70e3, elec = 80, gas = 105), n.trees = fitted_model0$n.trees)
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#for (x in ls(pattern = "fitted_model")[-1]) {
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
head(nd)
v <- c("elec", "gas")
m <- fitted_model0
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
x <- cbind(nd, expand.grid(g))
dim(x)
head(x)
View(x)
nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
v <- c("elec", "gas")
m <- fitted_model0
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
x <- cbind(nd, expand.grid(g))
x$y <- predict.gbm(m, newdata = x, n.trees = m$n.trees)
head(x)
summary(x)
f <- paste0("y ~ ", paste(v, collapse = " + "))
f
f <- paste0("y ~ ", paste(v, collapse = " + "))
fit <- lm(formula = formula(f), data = x)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
n <- prettyNum(signif(coef(fit), 4))
names(n)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", n, names(n)), collapse = " + ")), fixed = TRUE)
fit
summary(fit)
eq
#for (x in ls(pattern = "fitted_model")[-1]) {  # Not sure if ls() works within package environment
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
nd
out <- subset(nd, select = c(mrate, div_pre, div_post, elec, gas))
out$cost <- eq
out
predictModel <- function(input) {
#input can either be csv file or data
nd <- if (is.character(input) && file.exists(input)) {
read.csv(input)
} else {
as.data.frame(input)
}
stopifnot("zip" %in% names(nd))
stopifnot("hhsize" %in% names(nd))
stopifnot("minors" %in% names(nd))
stopifnot("age" %in% names(nd))
#-----
# INPUT FOR TESTING:
#nd <- data.frame(state = "Texas", hhsize = 4, minors = 2, age = 50, income = 50e3, elec = 100)
#nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3)
# Assign geographic variables to 'nd' using zip code provided
nd <- merge(nd, zip_lookup)
# Adult pre-tax dividend amount
div.adult <- 377
# Estimate household marginal tax rate
nd$adults <- nd$hhsize - nd$minors
nd$mrate <- 0.15
# Calculate pre- and post-tax dividends
nd$div_pre <- round(div.adult * nd$adults + 0.5 * div.adult * pmin(2, nd$minors))
nd$div_post <- round(nd$div_pre * (1 - nd$mrate))
#------
# How does variation in income affect the result
# TO DO: THIS NEEDS TO REFLECT SPECIFIC INPUTS NOT INTEGRAL OVER ALL VALUES!!!
v <- c("elec", "gas")
m <- fitted_model0
i <- match(v, m$var.names)
g <- lapply(i, function(x) seq(from = min(m$var.levels[[x]]), to = max(m$var.levels[[x]]), length.out = 50))
names(g) <- v
x <- cbind(nd, expand.grid(g))
x$y <- predict.gbm(m, newdata = x, n.trees = m$n.trees)
f <- paste0("y ~ ", paste(v, collapse = " + "))
fit <- lm(formula = formula(f), data = x)
# Create a character vector giving the equation expression to be evaluated using the slider variables as inputs
n <- prettyNum(signif(coef(fit), 4))
names(n)[1] <- "1"
eq <- gsub(" * 1", "", gsub(":", " * ", paste(sprintf("%s * %s", n, names(n)), collapse = " + ")), fixed = TRUE)
#------
# Predict the slider preset values
#for (x in ls(pattern = "fitted_model")[-1]) {  # Not sure if ls() works within package environment
for (x in c("fitted_model1", "fitted_model2")) {
m <- get(x)
nd[[m$response.name]] <- round(predict.gbm(m, newdata = nd, n.trees = m$n.trees))
}
#------
# DEPRECATED
# pred <- setdiff(names(test), "y")
# fit0 <- lm(y ~ ., data = test)
# fit0 <- lm(y ~ poly(income, 1, raw = T) * poly(elec, 1, raw = T), data = test)
#fit <- lm(formula = formula(paste0("y ~ ", paste0("poly(", pred, ", degree = 3, raw = TRUE)"))), data = test)
#fit2 <- as.stepfun(isoreg(x = test$income, y = test$y))
#library(MonoPoly)
#fit3 <- monpol(y ~income, data = test, degree = 5, monotone = "increasing")
# Check fit
# plot(test)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 2)
# lines(x = test$income, y = predict(fit0, data.frame(income = test$income)), col = 3)
#-----
# Return results data frame
out <- subset(nd, select = c(div_pre, mrate, elec, gas))
out$cost <- eq
return(out)
}
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 3, age = 50, income = 50e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 50e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 4, minors = 2, age = 50, income = 30e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 7, minors = 2, age = 50, income = 30e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 2, minors = 0, age = 50, income = 30e3))
predictModel(nd <- data.frame(zip = "80524", hhsize = 2, minors = 0, age = 30, income = 30e3))
summary(fitted_model0)
predictModel(nd <- data.frame(zip = "80524", hhsize = 2, minors = 0, age = 30, income = 70e3))
library(exampleR)
round(1131 * (1 - 0.15))
449.6 + 0.4673 * 101 + 2.051 * 73
961-647
?roxygenize
library(roxygen2)
roxygenise()
library(devtools)
build()
library(exampleR)
nd <- data.frame(zip = "94062", na = 2, nc = 2, hinc = 50e3, hfuel = "Electricity", veh = "2", rms = "7")
predictModel(nd)
library(quantreg)
library(tidyverse)
#----------------------
shrinkModel <- function(b, data) {
orig <- predict(b, data)
tryFun <- function(i, x) {
tryCatch(
{
x[[i]] <- NULL
y = predict(x, data)
identical(y, orig)
},
error = function(cond) {
return(FALSE)
},
warning = function(cond) {
message(cond)
return(FALSE)
},
finally = {}
)
}
cand <- sort(sapply(b, object.size), decreasing = TRUE)
for (j in names(cand)) {
if (tryFun(j, b)) {
b[[j]] <- NULL
}
}
return(b)
}
#----------------------------------
dset <- read_rds("Data/Model fitting dataset.rds") %>%
filter(hinc_fpl >= 0.25, age >= 18, na >= 1, Electricity > 0, !(!hfuel %in% c("Electricity", "Other or none") & Heating == 0), !(veh > 0 & Gasoline == 0)) %>%
mutate(veh = as.character(veh),
veh = as.ordered(ifelse(veh %in% c(5, "6+"), "5+", veh)),
rms = ordered(ifelse(rms >= 12, "12+", rms), levels = c(1:11,"12+")),
hfuel = ifelse(hfuel == "LPG", "LPG/Propane", hfuel),
hfuel = factor(hfuel, levels = names(sort(table(hfuel), decreasing = TRUE))),
Gasoline = Gasoline / gasprice,
Electricity = Electricity / elecprice,
Heating = Heating / heatprice)
# Predictor variables that are "fixed"
# These include number of adults and children and household income (necessary for post-tax dividend calculation)
#  as well as heating fuel and any predictors based on household location (assigned via user zip code)
#fixed <- c("np", "na", "nc", "hinc", "hfuel", "state", "loc", "popd", "cdd", "hdd", grep("ratio", names(dset), value = TRUE), grep("_pindex", names(dset), value = TRUE))
#fixed <- c("np", "na", "nc", "hinc", "hinc_fpl", "hfuel", "state", "loc", "popd", "cdd", "hdd", grep("_ratio", names(dset), value = TRUE), grep("_index", names(dset), value = TRUE))
fixed <- c("np", "nc", "hinc", "hfuel", "state", "loc", "popd", "cdd", "hdd", grep("ratio", names(dset), value = TRUE))
# Selected additional predictor variables
pred <- c("veh", "rms")
# Full set of predictor variables
vars <- c(fixed, pred)
#----------------------------------
# Convert character variables to factors to avoid error generated by gbm()
i <- which(sapply(dset, class) == "character")
dset[i] <- lapply(dset[i], as.factor)
# Drop observations where numeric variables have extreme values
n <- which(sapply(dset, class) == "numeric")
n <- n[names(n) %in% vars]
rng <- lapply(n, function(i) {quantile(dset[[i]], probs = c(0.01, 0.99))})
for (i in 1:length(n)) {
vrng <- rng[[i]]
dset <- filter(dset, dset[[n[i]]] > vrng[1], dset[[n[i]]] < vrng[2])
}
